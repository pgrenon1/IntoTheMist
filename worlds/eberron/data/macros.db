{"_id":"4N7IKHDD1mW25wlr","name":"Crit!","permission":{"default":0,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false}},"scope":"global","command":"const table = game.tables.entities.find(t => t.name === \"Crit!\");\ntable.draw();","author":"23MNgdgGXBQFpf87","img":"icons/svg/explosion.svg","actorIds":[]}
{"_id":"7S2L4qoEqB1hylbC","name":"Fumble!","permission":{"default":0,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false}},"scope":"global","command":"const table = game.tables.entities.find(t => t.name === \"Fumble!\");\ntable.draw();","author":"23MNgdgGXBQFpf87","img":"icons/svg/falling.svg","actorIds":[]}
{"_id":"IcubXfL23nXQanRt","name":"Add Condition","permission":{"default":0,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false}},"scope":"global","command":"/**\n * Applies a status (requires CUB)\n * \n * Contains code for 0.75 and 0.6.6. If you're using 0.6.6, comment out the \"addCondition\" line (add // to front of line)\n * and uncomment the \"applyCondition\" line (remove //)\n *\n * Author: @ChazPls#3551\n */\n \nlet options = '';\ngame.cub.conditions.forEach((item) => {\n  options += `<option value=\"${item.name}\">\\n`;\n});\nlet content = `\n<form>\n  <div class=\"form-group\">\n    <label for=\"condition\">Condition:</label>\n    <input list=\"conditions\" id=\"condition\" name=\"condition\"/ autofocus>\n    <datalist id=\"conditions\">\n      ${options}\n    </datalist>\n  </div>\n</form>\n`\n \nnew Dialog({\n  title: `Select Condition`,\n  content: content,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply`,\n      callback: (html) => {\n        let condition = html.find('#condition').val();\n        if (!game.cub.conditions.some(el => el.name === condition)) {\n          return ui.notifications.info(\"Select a valid condition.\");\n        }\n \n        //apply the condition to selected tokens (0.6.6)\n        //game.cub.applyCondition(condition);\n \n\t//apply the condition to the selected tokens (0.7.5)\n\tgame.cub.addCondition(condition);\n \n      }\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`\n    },\n  },\n  default: \"yes\"\n}).render(true);\n \n(async () => {\n  await new Promise(resolve => setTimeout(resolve, 20));\n  let input = $('#condition').focus();\n})();","author":"23MNgdgGXBQFpf87","img":"icons/svg/silenced.svg","actorIds":[]}
{"name":"Show Token Actions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{},"scope":"global","command":"/*\n* Requires: DND5e.\n* Provides a dialog showing all action-triggered equipment, prepared and at-will spells, feats, and consumables,\n* as well as passive feats. Hopefully makes triggering actions easier without needing the character sheet open\n* all the time.\n* WARNING: Very ugly.\n* author/blame: ^ and stick#0520\n* with enormous help on the button events (and no blame to be attributed to): Skimble#8601\n*/\n\nclass ActionDialog extends Application {\n    super(options){\n    }\n\n    activateListeners(html) {\n        super.activateListeners(html);\n        const buttons = html.find(\"button[class='show-action-button']\");\n        \n        if (buttons.length > 0)\n            buttons.on(\"click\", event => {this.openActionTab(event, html);});\n    }   \n      \n    openActionTab(event, html) {\n        // Declare all variables\n        var i, tabcontent, tablinks;\n      \n        // Get all elements with class=\"tabcontent\" and hide them\n        tabcontent = document.getElementsByClassName(\"show-action-category\");\n        for (let t of tabcontent) {\n          t.style.display = \"none\";\n        }\n      \n        // Get all elements with class=\"tablinks\" and remove the class \"active\"\n        tablinks = document.getElementsByClassName(\"show-action-button\");\n        for (let t of tablinks) {\n          t.className = t.className.replace(\" active\", \"\");\n        }\n      \n        // Show the current tab, and add an \"active\" class to the button that opened the tab\n        if (event.target.value == \"showActionAll\") {\n            tabcontent = document.getElementsByClassName(\"show-action-category\");\n            for (let t of tabcontent) {\n                t.style.display= \"block\";\n            }\n        } else {\n            if (document.getElementById(event.target.value) != null)\n                document.getElementById(event.target.value).style.display = \"block\";\n        }\n        event.currentTarget.className += \" active\";\n    } \n\n    getData(){\n        // Get user's character or the first token from the controlled list.\n        function getTargetActor() {\n            const character = game.user.character;\n            if (character != null)\n                return character;\n\n            const controlled = canvas.tokens.controlled;\n\n            if (controlled.length === 0) return character || null;\n\n            if (controlled.length > 0 && controlled[0] != null) {\n                return controlled[0].actor;\n            }\n        }\n\n        function buildActionsList(targetActor) {\n            let equipped = targetActor.data.items.filter(i => i.type !=\"consumable\" && i.data.equipped);\n            let activeEquipped = getActiveEquipment(equipped);\n            let weapons = activeEquipped.filter(i => i.type == \"weapon\");\n            let equipment = activeEquipped.filter(i => i.type == \"equipment\");\n\n            let other = activeEquipped.filter(i => i.type != \"weapon\" && i.type != \"equipment\");\n            let consumables = targetActor.data.items.filter(i => i.type == \"consumable\");\n            let items = { \"weapons\": weapons, \"equipment\": equipment, \"other\": other, \"consumables\": consumables };\n\n            let preparedSpells = targetActor.data.items.filter(i => i.type == \"spell\" && i.data.preparation.prepared);\n            let spells = categoriseSpells(preparedSpells);\n\n            let allFeats = targetActor.data.items.filter(i => i.type == \"feat\");\n            let activeFeats = getActiveFeats(allFeats);\n            let passiveFeats =  getPassiveFeats(allFeats);\n            let feats = {\"active\": activeFeats, \"passive\": passiveFeats};\n            \n\n            return { \"equipment\": items,\"spells\": spells, \"feats\": feats };\n        }\n\n        function getActiveEquipment(equipment) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n\n            let activeEquipment = equipment.filter(e => {\n                if (e.data.activation == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (e.data.activation.type == key)\n                        return true;\n                }\n                \n                return false;\n            });\n\n            return activeEquipment;\n        }\n\n        function categoriseSpells(spells) {\n            let powers = {};\n            let book = {}\n\n            book = spells.reduce(function (book, spell) {\n                var level = spell.data.level;\n                let prep = spell.data.preparation.mode;\n\n                const prepTypes = game.dnd5e.config.spellPreparationModes;\n                let prepType = prepTypes[prep];\n\n                if (prep == \"pact\" || prep == \"atwill\" || prep == \"innate\") {\n                    if (!powers.hasOwnProperty(prepType)) {\n                        powers[prepTypes[prep]] = [];\n                    }\n\n                    powers[prepType].push(spell);\n                } else {\n                    if (!book.hasOwnProperty(level)) {\n                        book[level] = [];\n                    }\n\n                    book[level].push(spell);\n                }\n\n                return book;\n            }, {});\n            \n            return {\"book\": Object.entries(book), \"powers\": Object.entries(powers)};\n        }\n\n        function getActiveFeats(feats) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n            let activeFeats = feats.filter(f => {\n                if (f.data.activation == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (f.data.activation.type == key)\n                        return true;\n                }\n                \n                return false;\n            });\n\n            return Object.entries(activeFeats);\n        }\n\n        function getPassiveFeats(feats) {\n            const activationTypes = Object.entries(game.dnd5e.config.abilityActivationTypes);\n            let passiveFeats = feats.filter(f => {\n                if (f.data.activation == undefined)\n                    return false;\n\n                for (let [key, value] of activationTypes) {\n                    if (f.data.activation.type == key)\n                        return false;\n                }\n                \n                return true;\n            });\n\n            return Object.entries(passiveFeats);\n        }\n\n        function getContentTemplate(actions) {\n            let template = `\n            <div>\n                 ${getCssStyle()}\n                <div class=\"show-action-form-group\">\n                    <div class=\"show-action-buttons\">\n                        <button value=\"showActionItems\" class=\"show-action-button\">Items</button>\n                        <button value=\"showActionSpells\" class=\"show-action-button\">Spells</button>\n                        <button value=\"showActionFeats\" class=\"show-action-button\">Feats</button>\n                        <button value=\"showActionAll\" class=\"show-action-button\">Show all</button>\n                    </div>\n                    </div>\n                    <div class=\"show-action-categories\">\n                        <div id=\"showActionItems\" class=\"show-action-category\">\n                            ${getItemsTemplate(actions.equipment)}\n                        </div>\n                        <div id=\"showActionSpells\" class=\"show-action-category\">\n                            ${getSpellsTemplate(actions.spells)}\n                        <div id=\"showActionFeats\" class=\"show-action-category\">\n                            ${getFeatsTemplate(actions.feats)}\n                        </div>\n                    </div>\n                </div>\n            </div>`;\n            \n            return template;\n        }\n\n                // Gets a template of abilities or skills, based on the type of check chosen.\n        function getItemsTemplate(items) {\n            if (items.weapons.length + items.equipment.length + items.other.length + items.consumables.length === 0)\n                return \"\";\n\n            let template = `<div id=\"actionItems\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Items</div>\n                                    ${getItemsCategoryTemplate(\"Weapons\", items.weapons)}\n                                    ${getItemsCategoryTemplate(\"Equipment\", items.equipment)}\n                                    ${getItemsCategoryTemplate(\"Other\", items.other)}\n                                    ${getItemsCategoryTemplate(\"Consumables\", items.consumables)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n\n        function getSpellsTemplate(spells) {                \n            let template = `<div id=\"actionSpells\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Spells</div>\n                                    ${getSpellsCategoryTemplate(spells.powers)}\n                                    ${getSpellsCategoryTemplate(spells.book)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n        \n        function getFeatsTemplate(feats) {\n            if (feats.active.length + feats.passive.length === 0)\n                return \"\";\n\n            let template = `<div id=\"actionFeats\" class=\"show-action-tabcontent\">\n                                <div class=\"show-action-tabcontent-title\">Feats</div>\n                                    ${getFeatsCategoryTemplate(\"Active\", feats.active)}\n                                    ${getFeatsCategoryTemplate(\"Passive\", feats.passive)}\n                                </div>\n                            </div>`;\n\n            return template;\n        }\n\n        function getItemsCategoryTemplate(title, items) {\n            if (items.length === 0)\n                return \"\";\n\n            let template = `<div class=\"show-action-tabcontent-subtitle\">${title}</div>\n                            <div class=\"show-action-tabcontent-actions\">`;\n            for (let i of items) {\n                template += `<input id=\"weapon-${i.name}\" type=\"button\" value=\"${i.name}\" onclick=\"${getRollItemMacro(i.name)}\"/>`;    \n            } \n\n            template += `</div>`;\n\n            return template;\n        }\n\n        function getSpellsCategoryTemplate(spells) {\n            if (spells.length === 0)\n                return \"\";\n\n            let template = \"\";\n\n            for (let [level, entries] of spells) {\n                console.log(isNumber(level.toString()));\n                let subtitle = !isNumber(level) ? level : (level === 0 ? `Cantrips` : `Level ${level}`);\n\n                template += `<div class=\"show-action-tabcontent-subtitle\">${subtitle}</div>\n                                <div class=\"show-action-tabcontent-actions\">`;\n        \n                for (let s of entries) {\n                    template += `<input id=\"spell-${s.name}\" type=\"button\" value=\"${s.name}\" onclick=\"${getRollItemMacro(s.name)}\"/>`;    \n                }\n    \n                template += `</div>`;\n            }\n            \n            return template;\n        }\n\n        function getFeatsCategoryTemplate(subtitle, feats) {\n            if (feats.length === 0)\n                return \"\";\n            \n            let template = `<div class=\"show-action-tabcontent-subtitle\">${subtitle}</div>\n                            <div class=\"show-action-tabcontent-actions\">`\n                            \n            for (let [index, f] of feats) {\n                template += `<input id=\"feat-${f.name}\" type=\"button\" value=\"${f.name}\" onclick=\"${getRollItemMacro(f.name)}\"/>`;    \n            }\n\n            template += `</div>`\n            \n\n            return template;\n        }\n\n        function getCssStyle() {\n            return `\n            <style type=\"text/css\">\n            .show-action-buttons {\n                display: grid;\n                grid-template-columns: repeat(5, 1fr);\n                grid-gap: 10px;\n            }\n\n            .show-action-buttons button {\n                width: auto;\n                height: auto;\n                background-color: #eee;\n                float: left;\n                border: none;\n                outline: none;\n                cursor: pointer;\n                padding: 5px 8px;\n                transition: 0.3s;\n                display: block;\n              }\n                            \n              /* Change background color of buttons on hover */\n              .show-action-buttons button:hover {\n                background-color: #ddd;\n              }\n              \n              /* Create an active/current tablink class */\n              .show-action-buttons button.active {\n                background-color: #ccc;\n              }\n\n              .show-action-categories {\n                clear: both;\n              }\n              \n              /* Style the tab content */\n              .show-action-tabcontent {\n                display: block;\n                padding: 6px 12px;\n                border: 1px solid #ccc;\n                border-bottom: none;\n                border-left: none;\n                border-right: none;\n              }\n\n              .show-action-tabcontent-title {\n                    clear: both;\n                    font-size: large;\n              }\n\n              .show-action-tabcontent-subtitle {\n                  padding: 5px;\n                  margin: 2px;\n                  float: left;\n              }\n\n              .show-action-tabcontent input {\n                border: 1px solid #555;\n                padding: 5px;\n                margin: 2px;\n              }\n              \n              .show-action-tabcontent input:hover {\n              background-color: #ddd;\n              }\n            </style>`\n        }\n\n        function getRollItemMacro(itemName) {\n            return `game.dnd5e.rollItemMacro(&quot;${itemName}&quot;)`;\n        }\n\n        // set this to true if you want results whispered to the GM\n        let targetActor = getTargetActor();\n        let innerContent = \"\";\n\n        if (targetActor != null || targetActor) {\n            this.options.title = `${targetActor.name} actions`;\n            let actionLists = buildActionsList(targetActor);\n            innerContent = getContentTemplate(actionLists);\n        } else {\n            ui.notifications.error(\"No token selected or user character found.\");\n            throw new Error(\"No token selected or character found\");\n        }\n        \n        var content =  `<div id=\"actionDialog\">${innerContent}</div>`;\n        var contentsObject = {content:`${content}`}\n        return contentsObject;\n    }\n}\n\nlet opt=Dialog.defaultOptions;\nopt.resizable=true;\nopt.title=\"Choose action\";\nopt.minimizable=true;\nopt.width=600;\nvar viewer;\nviewer = new ActionDialog(opt);\nviewer.render(true);\n","author":"23MNgdgGXBQFpf87","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"UBMc5B5AU142OrbC"}
{"name":"Light Picker","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{},"scope":"global","command":"function tokenUpdate(data) {\n  canvas.tokens.controlled.map(token => token.update(data));\n}\n\nlet torchAnimation = {\"type\": \"torch\", \"speed\": 1, \"intensity\": 1};\n\nlet dialogEditor = new Dialog({\n  title: `Token Light Picker`,\n  content: `Pick the light source the selected token is holding.`,\n  buttons: {\n    none: {\n      label: `None`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": null, \"brightLight\": null, \"lightAngle\": 360,});\n        dialogEditor.render(true);\n      }\n    },\n    torch: {\n      label: `Torch`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 40, \"brightLight\": 20, \"lightAngle\": 360, \"lightAnimation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    light: {\n      label: `Light cantrip`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 40, \"brightLight\": 20, \"lightAngle\": 360, \"lightAnimation\": {\"type\": \"none\"}});\n        dialogEditor.render(true);\n      }\n    },\n    lamp: {\n      label: `Lamp`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 45, \"brightLight\": 15, \"lightAngle\": 360, \"lightAnimation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    bullseye: {\n      label: `Bullseye Lantern`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 120, \"brightLight\": 60, \"lightAngle\": 45, \"lightAnimation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    hoodedOpen: {\n      label: `Hooded Lantern (Open)`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 60, \"brightLight\": 30, \"lightAngle\": 360, \"lightAnimation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    hoodedClosed: {\n      label: `Hooded Lantern (Closed)`,\n      callback: () => {\n        tokenUpdate({\"dimLight\": 5, \"brightLight\": 0, \"lightAngle\": 360, \"lightAnimation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {}\n});\n\ndialogEditor.render(true)","author":"23MNgdgGXBQFpf87","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"WWHlQT4M0LE81rfT"}
{"_id":"cbeYAfFZsYRLT7Kf","name":"All Token’s Passive Perception","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""}},"scope":"global","command":"// Pull the passive perception of each token in the current scene and whisper the results to the GM.\n// Only tested with the 5e System in Foundry.\n// Author: @Drunemeton#7955. Based on the original macro by author @Erogroth#7134.\n\n// Initalize variables.\nlet pcArray = [];\nlet npcArray = [];\nlet messageContentPC = \"\";\nlet messageContentNPC = \"\";\nlet messageHeaderPC = \"<b>PC Passive Perception</b><br>\";\nlet messageHeaderNPC = \"<b>NPC Passive Perception</b><br>\";\n\n// Gather tokens in the current scene into an array.\nlet tokens = canvas.tokens.placeables.filter((token) => token.data);\n\n// From the tokens array sort into PC and NPC arrays.\nfor (let count of tokens) {\n  let tokenType = count.actor.data.type;\n  let tokenName = count.data.name;\n    if (count.actor.data.data.hasOwnProperty('skills')) {\n        let tokenPassive = count.actor.data.data.skills.prc.passive;\n    \n    if(tokenType === \"character\") {\n      pcArray.push({ name: tokenName, passive: tokenPassive });\n    } \n    if(tokenType === \"npc\") {\n      npcArray.push({ name: tokenName, passive: tokenPassive });\n    }\n  }\n}\n\n// Sort each array.\nsortArray(pcArray);\nsortArray(npcArray);\n\n// Build chat message, with PCs first, then NPCs.\nfor (let numPC of pcArray) {\n  messageContentPC += `${numPC.name}: <b>${numPC.passive}</b><br>`;\n}\nfor (let numNPC of npcArray) {\n  messageContentNPC += `${numNPC.name}: <b>${numNPC.passive}</b><br>`;\n}\n\nlet chatMessage = (messageHeaderPC + messageContentPC + `<br>` + messageHeaderNPC + messageContentNPC);\n\nlet chatData = {\n  user: game.user._id,\n  speaker: ChatMessage.getSpeaker(),\n  content: chatMessage,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\n\n// Display chat message.\nChatMessage.create(chatData, {});\n\n// Sort each array by Name.\n  function sortArray(checkArray) {\n    checkArray.sort(function (a, b) {\n      var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n      var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n      if (nameA < nameB) {\n        return -1;\n      }\n      if (nameA > nameB) {\n        return 1;\n      }\n      // names must be equal\n      return 0;\n    });\n\n    // Sort array by Passive Perception.\n    checkArray.sort(function (a, b) {\n      return b.passive - a.passive;\n    });\n  }","author":"23MNgdgGXBQFpf87","img":"icons/svg/eye.svg","actorIds":[]}
{"_id":"j3sgySBIgq2qM2ZG","name":"Token Vision Configuration","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""}},"scope":"global","command":"// A macro for the Foundry virtual tabletop that lets a user configure their token's vision and lighting settings. This script is taken from Sky's foundry repo here: https://github.com/Sky-Captain-13/foundry/blob/master/scriptMacros/tokenVision.js.\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Token Vision Configuration`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Vision Type:</label>\n        <select id=\"vision-type\" name=\"vision-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"dim0\">Self</option>\n          <option value=\"dim30\">Darkvision (30 ft)</option>\n          <option value=\"dim60\">Darkvision (60 ft)</option>\n          <option value=\"dim90\">Darkvision (90 ft)</option>\n          <option value=\"dim120\">Darkvision (120 ft)</option>\n          <option value=\"dim150\">Darkvision (150 ft)</option>\n          <option value=\"dim180\">Darkvision (180 ft)</option>\n          <option value=\"bright120\">Devil's Sight (Warlock)</option>\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>Light Source:</label>\n        <select id=\"light-source\" name=\"light-source\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"none\">None</option>\n          <option value=\"candle\">Candle</option>\n          <option value=\"lamp\">Lamp</option>\n          <option value=\"bullseye\">Lantern (Bullseye)</option>\n          <option value=\"hooded-dim\">Lantern (Hooded - Dim)</option>\n          <option value=\"hooded-bright\">Lantern (Hooded - Bright)</option>\n          <option value=\"light\">Light (Cantrip)</option>\n          <option value=\"torch\">Torch</option>\n          <option value=\"moon-touched\">Moon-Touched</option>\n        </select>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      for ( let token of canvas.tokens.controlled ) {\n        let visionType = html.find('[name=\"vision-type\"]')[0].value || \"none\";\n        let lightSource = html.find('[name=\"light-source\"]')[0].value || \"none\";\n        let dimSight = 0;\n        let brightSight = 0;\n        let dimLight = 0;\n        let brightLight = 0;\n        let lightAngle = 360;\n        let lockRotation = token.data.lockRotation;\n        let lightAnimation = token.data.lightAnimation;\n        let lightAlpha = token.data.lightAlpha;\n        let lightColor = token.data.lightColor;\n        const colorFire = \"#f8c377\";\n        const colorWhite = \"#ffffff\";\n        const colorMoonGlow = \"#f4f1c9\";\n        // Get Vision Type Values\n        switch (visionType) {\n          case \"dim0\":\n            dimSight = 0;\n            brightSight = 0;\n            break;\n          case \"dim30\":\n            dimSight = 30;\n            brightSight = 0;\n            break;\n          case \"dim60\":\n            dimSight = 60;\n            brightSight = 0;\n            break;\n          case \"dim90\":\n            dimSight = 90;\n            brightSight = 0;\n            break;\n          case \"dim120\":\n            dimSight = 120;\n            brightSight = 0;\n            break;\n          case \"dim150\":\n            dimSight = 150;\n            brightSight = 0;\n            break;\n          case \"dim180\":\n            dimSight = 180;\n            brightSight = 0;\n            break;\n          case \"bright120\":\n            dimSight = 0;\n            brightSight= 120;\n            break;\n          case \"nochange\":\n          default:\n            dimSight = token.data.dimSight;\n            brightSight = token.data.brightSight;\n        }\n        // Get Light Source Values\n        switch (lightSource) {\n          case \"none\":\n            dimLight = 0;\n            brightLight = 0;\n            lightAnimation = {type: \"none\"};\n            break;\n          case \"candle\":\n            dimLight = 10;\n            brightLight = 5;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"lamp\":\n            dimLight = 45;\n            brightLight = 15;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"bullseye\":\n            dimLight = 120;\n            brightLight = 60;\n            lockRotation = false;\n            lightAngle = 52.5;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"hooded-dim\":\n            dimLight = 5;\n            brightLight = 0;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"hooded-bright\":\n            dimLight = 60;\n            brightLight = 30;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"light\":\n            dimLight = 40;\n            brightLight = 20;\n            lightAnimation = {type: \"none\"};\n            lightColor = colorWhite;\n            break;\n          case \"torch\":\n            dimLight = 40;\n            brightLight = 20;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"moon-touched\":\n            dimLight = 30;\n            brightLight = 15;\n            lightAnimation = {type: \"none\"};\n            lightColor = colorMoonGlow;\n            break;\n          case \"nochange\":\n          default:\n            dimLight = token.data.dimLight;\n            brightLight = token.data.brightLight;\n            lightAngle = token.data.lightAngle;\n            lockRotation = token.data.lockRotation;\n            lightAnimation = token.data.lightAnimation;\n            lightAlpha = token.data.lightAlpha;\n            lightColor = token.data.lightColor;\n        }\n        // Update Token\n        console.log(token);\n        token.update({\n          vision: true,\n          dimSight: dimSight,\n          brightSight: brightSight,\n          dimLight: dimLight,\n          brightLight:  brightLight,\n          lightAngle: lightAngle,\n          lockRotation: lockRotation,\n          lightAnimation: lightAnimation,\n          lightAlpha: lightAlpha,\n          lightColor: lightColor\n        });\n      }\n    }\n  }\n}).render(true);","author":"23MNgdgGXBQFpf87","img":"icons/svg/fire.svg","actorIds":[]}
{"_id":"rq460dDntf0W8DNv","name":"Remove Conditions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""}},"scope":"global","command":"for ( let token of canvas.tokens.controlled ){\n  await token.update({\"effects\": []});\n}","author":"23MNgdgGXBQFpf87","img":"icons/svg/pill.svg","actorIds":[]}
{"name":"Random Cutting Words","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random cutting word from a table called \"Mockeries\" along with the roll reduction.\n// You can find a mockeries table in the community table module.\n\nlet cuttingWords = () => {\n  // Setup variables\n  let tableName = \"Mockeries\";\n  let mockery = \"Now go away or I shall taunt you a second time-a!\"; // if table can't be found, use this.\n\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n  \n  let actorLevels = actor.data.data.levels || 1;\n  let table = game.tables.entities.find(t => t.name == tableName);\n  // Get Targets name\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      let roll = table.roll();\n      let result = roll.results[0];\n      mockery = result.text;\n      table.updateEmbeddedEntity(\"TableResult\", {\n        _id: result._id,\n        drawn: true\n      });\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  let dieType = 'd6';\n  if (actorLevels >= 15) {\n    dieType = 'd12';\n  } else if (actorLevels >= 10) {\n    dieType = 'd10';\n  } else if (actorLevels >= 5) {\n    dieType = 'd8';\n  }\n\n  let messageContent = `<p>${targetName} Reduce your roll by: <b>[[1${dieType}]]</b>.</p>`\n  messageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\n  messageContent += `<details closed=\"\"><summary><a>Cutting Words</a></summary>\n  <p>When a creature that you can see within 60 feet of you makes an <b>Attack roll, an ability check, or a damage roll</b>, you can use your <b>Reaction</b> to expend one of your uses of <b>Bardic Inspiration</b>,\n  rolling a Bardic Inspiration die and subtracting the number rolled from the creature’s roll.</p>\n  <p>You can choose to use this feature after the creature makes its roll, but before the GM determines whether the Attack roll or ability check succeeds or fails, or before the creature deals its damage. \n  The creature is immune if it can’t hear you or if it’s immune to being <b>Charmed</b>.</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user._id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\n\ncuttingWords();\n","author":"23MNgdgGXBQFpf87","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"s6Q4GrElJnjy7op6"}
{"_id":"tMMdZzbkwBDG88MX","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""}},"scope":"global","command":"// Grabs selected tokens and rolls a stealth check against all other tokens passive perception on the map. Then returns the result.\n\n// getting all actors of selected tokens\nlet actors = canvas.tokens.controlled.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.total; // stealth roll\n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});","author":"23MNgdgGXBQFpf87","img":"icons/svg/mystery-man-black.svg","actorIds":[]}
{"name":"Breathing Lights","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{},"scope":"global","command":"// Courtesy of @ohporter\n// Cause lightsources to \"breathe,\" expanding and contracting.\n(async () => {\n    let min = 5;\n    let max = 10;\n    if (game.pulsatingLights) {\n      game.pulsatingLights = false;\n    } else {\n      game.pulsatingLights = true;\n      let glyphLights = [];\n      let glyphColor = \"#5940b5\"\n      let scene = game.scenes.active;\n  \n      canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === glyphColor && l.scene === scene) glyphLights.push(l.id) })\n  \n      const updates = []\n  \n      let radius = min;\n      let increment = true;\n      let interval = setInterval(async () => {\n        glyphLights.forEach(id => {\n          updates.push({ _id: id, dim: radius, bright: radius/2});\n        })\n        await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n  \n        if (increment) {radius += 1} else {radius -= 1};\n        if (radius === max) {increment = false};\n        if (radius === min) {increment = true};\n        if (!scene.active || !game.pulsatingLights) {\n          // Reset to default glow\n          glyphLights.forEach(id => {\n            updates.push({ _id: id, dim: min, bright: 0});\n          })\n          await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  })()","author":"23MNgdgGXBQFpf87","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"uQ8jJgBpN2leuUn4"}
{"name":"Random Mockeries","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random mockery from a table called \"mockeries\" along with the DC and damage.\n// You can find a table called mockeries in the community tables module.\n\n\nlet tableName = \"Mockeries\";\n// default mockery if no table found.\nlet mockery = \"Now go away or I shall taunt you a second time-a!\";\n\nlet viciousMockeries = () => {\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n\n  let actorLevels = actor.data.data.levels || 1;\n  let table = game.tables.entities.find(t => t.name == tableName);\n\n  // Get Targets name\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      let roll = table.roll();\n      let result = roll.results[0];\n      mockery = result.text;\n      table.updateEmbeddedEntity(\"TableResult\", {\n        _id: result._id,\n        drawn: true\n      });\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  // Add a message with damage roll\n  let numDie = 1;\n  if (actorLevels >= 17) {\n    numDie = 4;\n  } else if (actorLevels >= 11) {\n    numDie = 3;\n  } else if (actorLevels >= 5) {\n    numDie = 2;\n  }\n\n  let messageContent = `<p>${targetName} Roll WIS save DC [[8+${actor.data.data.abilities.cha.mod}+@attributes.prof]] or take [[${numDie}d4]] damage and have disadvantage.</p>`\n  messageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\n  messageContent += `<details closed=\"\"><summary><a>Vicious Mockery</a></summary><p>You unleash a string of insults laced with subtle enchantments at a creature you can see within range. If the target can hear you (though it need not understand you), it must succeed on a <strong>Wisdom saving throw</strong> or take <strong>1d4 psychic damage</strong> and have <strong>disadvantage on the next attack roll</strong> it makes before the end of its next turn.</p>\n    <p>This spell’s damage increases by 1d4 when you reach 5th level ([[/r 2d4]]), 11th level ([[/r 3d4]]), and 17th level ([[/r 4d4]]).</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user._id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\n\nviciousMockeries();\n","author":"23MNgdgGXBQFpf87","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"utKUqTmnEDUJ1Nnh"}
{"_id":"zgfDr0Uu1Jl1GhDQ","name":"Guidance","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3,"23MNgdgGXBQFpf87":3},"type":"script","sort":100001,"flags":{"combat-utility-belt":{"macroTrigger":""}},"scope":"global","command":"// new build for guidance macro by Mr.White and Penguin#0949 and with no help all of Kotetsushin#7680 trust me \n// Edited by DrWiFi to roll guidance on skill checks as well, removed references to bless spell\n// version beta 3.1.1 for workgroups .2\n\n// user notes\n// this macro is intended for use by the recipient of the guidance spell in D&D 5e on Forge VTT\n// N.B. every recipient will need to use this macro independently on their own Actor/token.\n\n//user modifiable declarations CHANGE AT YOUR OWN RISK\nconst guidanceIconPath = 'icons/svg/windmill.svg';\nlet guidanceMsg = ' is guided!';\nlet endguidanceMsg = ' is no longer guided.';\n\n//fixed declarations DO NOT MODIFY\nlet Guidd4 = '+1d4';\nlet guided = '';\nlet chatMsg = '';\nlet macroActor = actor;\nlet macroToken = token;\n\n//identify token\nif (macroToken === undefined || macroToken === null) {\n  ui.notifications.warn(\"Please select a token first.\");\n} else {\n// grab curent global states\n\tlet abilities = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.abilities.check));\n\tlet skills = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.abilities.skill));\n\tif(abilities.includes(Guidd4)){\n\t\tguided = true;\n\t}\n// If not already guided\t\n\tif (guided == false || guided === null || guided === undefined || guided == \"\") {\t\n// toggle guidance icon\n\t\tmacroToken.toggleEffect(guidanceIconPath);  \n// anounce to chat\n\t\tchatMsg = `${macroActor.name} ${guidanceMsg}`;\n// add guidance bonus\n\t\tconsole.log('adding guidance modifiers to global bonuses');\n\t\tlet obj = {};\n\t\tobj['data.bonuses.abilities.check'] = abilities + Guidd4;\n\t\tobj['data.bonuses.abilities.skill'] = skills + Guidd4;\n\t\tmacroActor.update(obj);\n// if already guided\t\n\t}\telse if (guided == true) {\n// toggle guidance icon\n\t\ttoken.toggleEffect(guidanceIconPath);  \t\t\n// anounce to chat\n\t\tchatMsg = `${macroActor.name} ${endguidanceMsg}`;\n// remove guidance bonus\n\t\tconsole.log('resetting global bonuses for guidance');\n\t\tlet obj = {};\n\t\tvar tmp = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.abilities.check));\n\t\tvar tmpLength = tmp.indexOf(Guidd4);\n        tmp = tmp.substring(0, tmpLength) + tmp.substring(tmpLength+4, tmp.length);\n\t\tobj['data.bonuses.abilities.check'] = tmp;\n\t\tvar tmp = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.abilities.skill));\n\t\tvar tmpLength = tmp.indexOf(Guidd4);\n        tmp = tmp.substring(0, tmpLength) + tmp.substring(tmpLength+4, tmp.length);\n\t\tobj['data.bonuses.abilities.skill'] = tmp;\n\t\tmacroActor.update(obj);\n\t}\n}\n  \t\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}","author":"23MNgdgGXBQFpf87","img":"icons/svg/windmill.svg","actorIds":[]}
