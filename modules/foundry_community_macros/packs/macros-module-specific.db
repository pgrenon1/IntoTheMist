{"_id":"OJGjAdWyYptiGeBa","name":"Token Vision Config - About Time","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// A macro for the Foundry virtual tabletop that lets a user configure their token's vision and lighting settings, based on lighting sources from D&D 5e. Has a dependency on About Time by Tim Posney.\n\nif (canvas.tokens.controlled.length === 0)\n  ui.notifications.error(\"Please select a token\");\n\nlet namedfields = (...fields) => {\n  return (...arr) => {\n    var obj = {};\n    fields.forEach((field, index) => {\n      obj[field] = arr[index];\n    });\n    return obj;\n  };\n};\n\n// Very ugly automated construction below. DRY, but at what cost?\nlet VisionType = namedfields('name', 'dim', 'bright');\nvar visions = (() => {\n  return [\n    VisionType('Leave Unchanged', null, null),\n    VisionType('Self', 5, 0),\n    VisionType('Devil\\'s Sight', 0, 120)\n  ].concat(...[...Array(6).keys()].map(x => (x+1)*30).map(n => {\n    return VisionType(`Darkvision (${n} feet)`, n, 0);\n  }));\n})();\n\nlet LightSource = namedfields('name', 'dim', 'bright', 'angle', 'lockRotation')\nvar lightSources = [\n  LightSource('Leave Unchanged', null, null, null, null),\n  LightSource('None', 0, 0, 360, null),\n  LightSource('Candle', 10, 5, 360, null),\n  LightSource('Torch / Light Cantrip', 40, 20, 360, null),\n  LightSource('Lamp', 45, 15, 360, null),\n  LightSource('Hooded Lantern', 60, 30, 360, null),\n  LightSource('Hooded Lantern (Dim)', 5, 0, 360, null),\n  LightSource('Bullseye Lantern', 120, 60, 52.5, false)\n];\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Token Vision Configuration`,\n  content: `\n<form>\n  <div class=\"form-group\">\n    <label>Vision Type:</label>\n    <select id=\"vision-type\" name=\"vision-type\">\n      ${\n        visions.map((vision, index) => {\n          return `\\t<option value=${index}>${vision.name}</option>`;\n        }).join('\\n')\n      }\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Light Source:</label>\n    <select id=\"light-source\" name=\"light-source\">\n      ${\n        lightSources.map((lightSource, index) => {\n          return `\\t<option value=${index}>${lightSource.name}</option>`;\n        }).join('\\n')\n      }\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Duration in Minutes:</label>\n    <input type=\"number\" id=\"duration\" name=\"duration\" min=\"0\">\n  </div>\n</form>\n`,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      for ( let token of canvas.tokens.controlled ) {\n        let visionIndex = parseInt(html.find('[name=\"vision-type\"]')[0].value) || 0;\n        let lightIndex = parseInt(html.find('[name=\"light-source\"]')[0].value) || 0;\n        let duration = parseInt(html.find('[name=\"duration\"]')[0].value) || 0;\n\n        if (duration > 0) {\n          if (game.modules.get(\"about-time\").active != true) {\n            ui.notifications.error(\"About Time isn't loaded\");\n          } else {\n            ((backup) => {\n              game.Gametime.doIn({minutes:Math.floor(3 * duration / 4)}, () => {\n                ChatMessage.create({\n                  user: game.user._id,\n                  content: \"The fire burns low...\",\n                  speaker: speaker\n                }, {});\n              });\n            })(Object.assign({}, token.data));\n            ((backup) => {\n              game.Gametime.doIn({minutes:duration}, () => {\n                ChatMessage.create({\n                  user: game.user._id,\n                  content: \"The fire goes out, leaving you in darkness.\",\n                  speaker: speaker\n                }, {});\n                token.update({\n                  vision: true,\n                  dimSight: backup.dimSight,\n                  brightSight: backup.brightSight,\n                  dimLight: backup.dimLight,\n                  brightLight:  backup.brightLight,\n                  lightAngle: backup.lightAngle,\n                  lockRotation: backup.lockRotation\n                });\n              });\n            })(Object.assign({}, token.data));\n          }\n        }\n\n        // Configure new token vision\n        let dimSight = visions[visionIndex].dim ?? token.data.dimSight;\n        let brightSight = visions[visionIndex].bright ?? token.data.brightSight;\n        let dimLight = lightSources[lightIndex].dim ?? token.data.dimLight;\n        let brightLight = lightSources[lightIndex].bright ?? token.data.brightLight;\n        let lightAngle = lightSources[lightIndex].angle ?? token.data.lightAngle;\n        let lockRotation = lightSources[lightIndex].lockRotation ?? token.data.lockRotation;\n        // Common settings for all 'torch-like' options\n        // Feel free to change the values to your liking\n        let lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n        let lightColor = \"#f8c377\"; // Fire coloring.\n        let lightAlpha = 0.15;\n\n        // Update Token\n        console.log(token);\n        token.update({\n          vision: true,\n          dimSight: dimSight,\n          brightSight: brightSight,\n          dimLight: dimLight,\n          brightLight:  brightLight,\n          lightAngle: lightAngle,\n          lockRotation: lockRotation,\n          lightAnimation: lightAnimation,\n          lightColor: lightColor,\n          lightAlpha: lightAlpha\n        });\n      }\n    }\n  }\n}).render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"VZeBTY7FM8tERZGe","name":"Open Beyond Sheet Player","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Here's one for your players if you are using Virtual Tabletop Assets - D&D Beyond Integration:\n// Requires https://www.vttassets.com/modules/vtta-dndbeyond with character sheets linked!\n\nlet popup = () => {\n  if (!game.user.character)\n      return ui.notifications.error(\"You must first have a character assigned to your user!\");\n\n  let char = game.user.character;\n\n  if (!char.data.flags.vtta && !char.data.flags.vtta.dndbeyond && !char.data.flags.vtta.dndbeyond.url)\n      return ui.notifications.error(\"Character must be linked with a D&D Beyond sheet!\");\n\n  let url = char.data.flags.vtta.dndbeyond.url;\n  let ratio = window.innerWidth / window.innerHeight;\n  let width = Math.round(window.innerWidth * 0.5);\n  let height = Math.round(window.innerWidth * 0.5 * ratio);\n  const dndBeyondPopup = window.open(\n      url,\n      \"ddb_sheet_popup\",\n      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n  );\n};\n\npopup();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"eAl2Dc1HLYp2sUeG","name":"Hit Die","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Requires furnace to work correctly.\n// args[0] === name of character\n// args[1] === \"add\",\"sub\", or \"use\" \n//\t\t\"add\" : adds 1 hit die if able to\n//\t\t\"sub\" : removes 1 hit die if able to\n//\t\t\"use\" : removes 1 hit die and heals actor for rolled amount\n\n(async () => {\n\tconst actor = game.actors.find(i => i.name === args[0]); \n    if (!actor) return ui.notifications.warn(`No Actor by that name available.`);\n    const classItems = actor.data.items.filter(it => it.type === \"class\")\n    if (!classItems.length) return ui.notifications.warn(`Actor has no class!`);\n    if (classItems.length > 1) return ui.notifications.warn(`Actor has multiple classes! This is not (yet) supported.`);\n    const classItem = classItems[0];\n\t\n\tif(args[1] === \"add\")\n\t{\n\t\tif (classItem.data.hitDiceUsed <= 0) return ui.notifications.warn(`You are at maximum Hitdie!`);\n\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed - 1,\n\t\t\t},\n\t\t};\n\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t}\n\t\n\tif(args[1] === \"sub\")\n\t{\n\t\tif (classItem.data.hitDiceUsed >= classItem.data.levels) return ui.notifications.warn(`You have no remaining hit dice to spend!`);\n\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed + 1,\n\t\t\t},\n\t\t};\n\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t}\n\t\n\tif(args[1] === \"use\")\n\t{\n\t\tif (classItem.data.hitDiceUsed >= classItem.data.levels) return ui.notifications.warn(`You have no remaining hit dice to spend!`);\t\t\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed + 1,\n\t\t\t},\n\t\t};\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t\t\n\t\tconst hitDieRoll = new Roll(`1${classItem.data.hitDice} + ${actor.data.data.abilities.con.mod}`);\n\t\thitDieRoll.roll();\n\t\thitDieRoll.toMessage({\n\t\t\tuser : game.user._id,\n\t\t\tspeaker : speaker,\n\t\t\tflavor : \"Roll Hit Dice\"\n\t\t});\n\t\t\n\t\tconst actorUpdate = {\n\t\t\tdata: {\n\t\t\t\tattributes: {\n\t\t\t\t\thp: {\n\t\t\t\t\t\tvalue: Math.clamped(\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.value + hitDieRoll.total,\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.min,\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.max\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t\tawait actor.update(actorUpdate);\n\t}    \n})();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Hunters Mark - Mark Attack Wrapper","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This marco is replacement for a rollItemMacro. Replace the name of the item\n//you wish to use to make the attack. This macro must be used with the\n//CastMark.json macro or it will just make a standard attack.\n\n// PUT ITEM MACRO HERE between quotes ****************\nconst itemName = \"Longbow\";\n// ***************************************************\n\n//parameters\n\nlet myToken = token;\nconst macroName = \"world\";\nconst markDmg = \" + 1d6\";\nconst target = game.user.targets.values().next().value;\nconst bonuses = myToken.actor.data.data.bonuses;\nconst actorId = myToken.actor._id + \"_mark\";\n\n//Check to see if the mark flag is set else make attack\n\nfunction checkMark() {\n  const flag = myToken.getFlag(macroName, actorId);\n\n  if (flag) {\n    if (flag.targetId == target.data._id) {\n      markAttack(flag);\n    } else {\n      baseAttack(flag);\n    }\n  } else {\n    game.dnd5e.rollItemMacro(itemName);\n  }\n}\n\n//check if the mark damag is set and if not increase\n//increase global damage by 1d6\n\nfunction markAttack(flag) {\n  if (!flag.isSet) {\n    let obj = {\n      \"data.bonuses.mwak.damage\": flag.meleeAtk + markDmg,\n      \"data.bonuses.rwak.damage\": flag.rangeAtk + markDmg,\n      \"data.bonuses.msak.damage\": flag.meleeSpell + markDmg,\n      \"data.bonuses.rsak.damage\": flag.rangeSpell + markDmg\n    };\n    updateActor(myToken, obj);\n    flag.isSet = true;\n  }\n  game.dnd5e.rollItemMacro(itemName);\n  token.setFlag(macroName, actorId, flag);\n}\n\n// check if the mark damage is set and if it is revert to base global damage\n\nfunction baseAttack(flag) {\n  if (flag) {\n    let obj = {\n      \"data.bonuses.mwak.damage\": flag.meleeAtk,\n      \"data.bonuses.rwak.damage\": flag.rangeAtk,\n      \"data.bonuses.msak.damage\": flag.meleeSpell,\n      \"data.bonuses.rsak.damage\": flag.rangeSpell\n    };\n    updateActor(myToken, obj);\n    flag.isSet = false;\n    game.dnd5e.rollItemMacro(itemName);\n    token.setFlag(macroName, actorId, flag);\n  } else {\n    game.dnd5e.rollItemMacro(itemName);\n  }\n}\n\nasync function updateActor(updateToken, obj) {\n  await updateToken.actor.update(obj);\n}\n\n//Ensure target is set and then call check mark function\n\nif (!myToken) ui.notifications.error(\"Please select your token first.\");\nelse {\n  checkMark();\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"m2Dqm2gD0sUDNWbI"}
{"_id":"pQ2VZCynMb4MIhky","name":"Resolve Surprise","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Resolve who is surprised between groups of players and enemies or individual players and enemies\n// This macro requires The Furnance module with \"Advanced Macros\" turned on.\n// ReadMe: https://gitlab.com/x.technocat/foundry-macros/-/blob/e67f9441b2d6d442258db1d51aa2be3ead97569d/surprise-macros/README.md\n\n// Get player character tokens\nconst playerActors = getPlayerActors();\n\n// Get hostile tokens\nconst enemyActors = getEnemyActors();\n\nlet warnMsg = \"\";\n\n// Main function\nconst isSuccessful = checkSurprise(playerActors, enemyActors);\n\nif (!isSuccessful) {\n  return ui.notifications.warn(warnMsg);\n}\n\nfunction checkSurprise(playerActors, enemyActors) {\n  if (!game.user.isGM) {\n    warnMsg = \"You do not have permission to run this macro.\";\n    return false;\n  }\n  if (!playerActors.length > 0) {\n    warnMsg =\n      \"Could not find player characters in the scene. Please add player characters to the scene.\";\n    return false;\n  }\n  if (!enemyActors.length > 0) {\n    warnMsg =\n      \"Could not find hostile tokens. You need tokens with hostile dispositions in the scene to check for Surprise!\";\n    return false;\n  }\n\n  // Displays a popup and handles the input. Thanks to PaperPunk for this.\n  let calculateSurprise = false;\n\n  new Dialog({\n    title: `What Group is Sneaking?`,\n    content: `\n    <form>\n      <div>\n        <label>Select which group is sneaking/ambushing:</label><br><br>\n        <div style=\"margin:auto; width: 50%;\">\n        <input type=\"radio\" name=\"sneaking-group\" id=\"enemies\" value=\"enemies\" checked=\"checked\">\n        <label for=\"enemies\"><b>Enemy</b> is sneaking</label><br>\n        <input type=\"radio\" name=\"sneaking-group\" id=\"party\" value=\"party\">\n        <label for=\"party\"><b>Party</b> is sneaking</label><br>\n        </div>\n        <br>\n      </div>\n    </form>\n    `,\n    buttons: {\n      yes: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: `Calculate Surprise`,\n        callback: () => (calculateSurprise = true), //if \"yes\" is selected, apply the selection.\n      },\n      no: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: `Cancel Surprise`,\n      },\n    },\n    // Defaulting to yes, so that when someone selects something and hits enter, it doesn't cancel:\n    default: \"yes\",\n\n    // Handle the input\n    close: (html) => {\n      if (calculateSurprise) {\n        // Determine which group is sneaking based on the user's selection\n        const sneakyOptions = html.find('[name=\"sneaking-group\"]'); \n        let sneakingGroup;\n        for (const option of sneakyOptions) {\n          if(option.checked) {\n            sneakingGroup = option.value;\n            break;\n          }\n        }      \n\n        let results = ``;\n        let lowestStealthCheck = 0;\n\n        switch (sneakingGroup) {\n          case \"enemies\":\n            lowestStealthCheck = rollStealth(enemyActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck,\n              playerActors\n            );\n            break;\n\n          case \"party\":\n            lowestStealthCheck = rollStealth(playerActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck, \n              enemyActors);\n            break;\n        }\n\n        handleChatMessage(results, lowestStealthCheck);\n      }\n    },\n  }).render(true); // display pop up window\n\n  return true; // no issues and we're done here!\n}\n\nfunction handleChatMessage(results, lowestStealth) {\n  let messageContent = ``;\n  messageContent += `<b>Lowest Stealth: </b> [[${lowestStealth}]] <br><br>`;\n  messageContent += results;\n\n  const surpriseRules =\n    \"<br><b>Surprise Rules</b><br>\" +\n    \"Compare the Dexterity (Stealth) checks of anyone hiding with the passive Wisdom (Perception) score of each creature on the opposing side. Any character or monster that doesn't notice <i><b>a</b></i> threat is surprised at the start of the encounter. <br><br>\" +\n    \"If you're surprised, you can't move or take an action on your first turn of the combat, and you can't take a reaction until that turn ends. A member of a group can be surprised even if the other members aren't.<br><br> <i>PHB. 189</i>\";\n\n  messageContent += surpriseRules;\n\n  let chatData = {\n    user: game.user._id,\n    speaker: game.user.name,\n    content: messageContent,\n    whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n  };\n\n  ChatMessage.create(chatData, {});\n}\n\nfunction getPlayerActors() {\n  // Get tokens in the scene that are player characters and not NPCs. Prioritize selected tokens.\n  const controlledPlayerActors = canvas.tokens.controlled\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n\n  if (controlledPlayerActors.length > 0) {\n    return controlledPlayerActors;\n  }\n\n  // If none are selected, use all the player characters in the scene\n  return canvas.tokens.children[0].children\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n}\n\nfunction getEnemyActors() {\n  // Prioritize selected hostile enemies\n  const controlledEnemyActors = canvas.tokens.controlled\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n\n  if (controlledEnemyActors.length > 0) {\n    return controlledEnemyActors;\n  }\n\n  // If none are selected, use all the enemies in the scene that are hostile\n  return canvas.tokens.children[0].children\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n}\n\nfunction rollStealth(sneakyGroup) {\n  // Roll stealth for the sneaking group\n  let stealthResults = [];\n  for (let actor of sneakyGroup) {\n    let stealth =\n      new Roll(\"1d20\").roll().total + actor.data.data.skills.ste.mod;\n    stealthResults.push(stealth);\n  }\n\n  // Return the lowest stealth roll, it's all we need\n  return Math.min(...stealthResults);\n}\n\nfunction calculateSurpriseResults(lowestStealth, perceptiveGroup) {\n  let resultMsg = ``;\n\n  const surprisedTxt = `[<span style=\"color:red\">Surprised</span>]`;\n  const notSurprisedTxt = `[<span style=\"color:green\">Not Surprised</span>]`;\n  const alertTxt = `<i>Alert</i>`;\n\n  const lowestPerception = Math.min.apply(\n    Math,\n    perceptiveGroup.map(function (actor) {\n      return actor.data.data.skills.prc.passive;\n    })\n  );\n\n  if (lowestPerception >= lowestStealth) {\n    resultMsg += `<i>No one is Surprised!</i> <br>`;\n  } else {\n    for (let actor of perceptiveGroup) {\n      const name = actor.data.name;\n      const prc = actor.data.data.skills.prc.passive;\n      let msg = ``;\n\n      // If Alert feat not surprised, else if win perception not surprised, else surprised\n      const alertFeat = actor.data.items.find((p) => p.name === \"Alert\");\n      if (alertFeat) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt} ${alertTxt}`;\n      } else if (prc >= lowestStealth) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt}`;\n      } else {\n        msg = `${name} (${prc}) -- ${surprisedTxt}`;\n      }\n\n      // Append this actor's surprise result to chat message variable.\n      resultMsg += `${msg} <div style=\"border-bottom: 1px solid gray\"></div> <br>`;\n    }\n  }\n\n  return resultMsg;\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Hunters Mark - GM Conditions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This macro must be called 'GMConditions' and be on the GM's\n//hot bar for the castMark.js macro to function correctly.\n//you must tick the option 'Excecute Macro As GM' to grant\n//players access to this macro.\n\n\nconst action = args[0]\nconst condition = args[1]\nconst targetId = args[2]\nconst target = canvas.tokens.get(targetId);\nif (action == \"apply\"){\n    game.cub.applyCondition(condition, target, {warn: true});\n}\nelse if (action == \"remove\"){\n    game.cub.removeCondition(condition, target, {warn: true});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"s7I9TcrGFMH2hQ0c"}
{"name":"Hunters Mark - Cast Mark","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This marco is designed to be used in conjunction with MarkAttackWrapper.json\n//and GMConditions.js.\n\n//It is designed to replace the standard rollItemMacro for either the Hex\n//spell or the hunter's mark Spell on either the warlock or ranger, but\n//it will work on any class with hex or hunter's mark by changing the Localization\n//parameters. To use hex, replace warlockName variable below and if you\n//would like to use it with hunter's mark replace rangerName variable below.\n\n// CAUTION! if you change your global damage variables while this macro is\n//active the change will be erased. It should work fine with dynamic effects.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//This macro is designed to be used with the combat utility belt module.\n//and the furnace module. Once you have it installed, you will have to enable \n//enhanced conditions, and create a condition called 'Marked' as the Localization \n//parameter below. You just need to update that parameter to match whatever condition \n//name you want if you want to use a different name in condition lab.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//Localization\nconst rangerName = \"Ranger\";\nconst warlockName = \"Warlock\";\nconst rangerSpell = \"Hunter's Mark\";\nconst warlockSpell = \"Hex\";\nconst condition = \"Marked\";\nconst flagScope = \"world\";\n\n//parameters\nif (!token) ui.notifications.error(\"Please select your token first.\");\nlet myToken = token;\nconst markDmg = \" + 1d6\";\nif (!game.user.targets.values().next().value) {\n  ui.notifications.error(\"Please select one target\");\n}\nconst target = game.user.targets.values().next().value;\n\nconst conditionList = target.data.effects;\nconst actorId = myToken.actor._id + \"_mark\";\nconst bonuses = myToken.actor.data.data.bonuses;\nlet className = \"\";\nlet spellName = \"\";\nlet gm_macro = null\n\n//Check to make sure that the GM has the GMConditions macro assigned.\ntry{\n    gm_macro = game.macros.entities.find(mb => mb.name === \"GMConditions\");\n}\ncatch(err)\n{\n    ui.notifications.error(\"GMConditions Macro was not found\")\n}\n\n//If Move flag and condition to a new selected target\nfunction move() {\n  let swapTarget = myToken.getFlag(flagScope, actorId);\n  const remCon = canvas.tokens.get(swapTarget.targetId);\n  gm_macro.execute(\"remove\", condition, swapTarget.targetId);\n  swapTarget.targetId = target.data._id;\n  (async () => {\n    await myToken.unsetFlag(flagScope, actorId);\n    myToken.setFlag(flagScope, actorId, swapTarget);\n  })();\n  gm_macro.execute(\"apply\", condition, target.id);\n  console.log();\n}\n\n//revert global damage to base, remove the condition and unset flag\n\nfunction remove() {\n  const flagId = myToken.getFlag(flagScope, actorId);\n\n  let obj = {\n    \"data.bonuses.mwak.damage\": flagId.meleeAtk,\n    \"data.bonuses.rwak.damage\": flagId.rangeAtk,\n    \"data.bonuses.msak.damage\": flagId.meleeSpell,\n    \"data.bonuses.rsak.damage\": flagId.rangeSpell\n  };\n\n  updateActor(myToken, obj);\n\n  const remFlag = canvas.tokens.get(flagId.targetId);\n\n  (async () => {\n    await gm_macro.execute(\"remove\", condition, flagId.targetId);\n    await myToken.unsetFlag(flagScope, actorId);\n  })();\n}\n\n// User input to move or remove flag and condition\n\nfunction alterMark() {\n  const d = new Dialog({\n    title: \"Mark Enemy\",\n    content: \"<p>Would you like to move or remove?</p>\",\n    buttons: {\n      one: {\n        icon: '<i class=\"fas fa-check\"></i>',\n        label: \"Move\",\n        callback: () => move()\n      },\n      two: {\n        icon: '<i class=\"fas fa-times\"></i>',\n        label: \"Remove\",\n        callback: () => remove()\n      }\n    },\n    default: \"two\",\n    close: () => console.log(\"Dialog closed\")\n  }).render(true);\n}\n\n// cast the spell, apply the condition, create and set flag\n\nasync function castSpell() {\n  try {\n    await game.dnd5e.rollItemMacro(spellName);\n  } catch (err) {\n    return null;\n  }\n  gm_macro.execute(\"apply\", condition, target.id);\n\n  let globalDmg = {\n    targetId: target.data._id,\n    meleeAtk: bonuses.mwak.damage,\n    rangeAtk: bonuses.rwak.damage,\n    meleeSpell: bonuses.msak.damage,\n    rangeSpell: bonuses.rsak.damage,\n    isSet: false\n  };\n  myToken.setFlag(flagScope, actorId, globalDmg);\n}\n\n//If the class is ranger and has the hunter's mark spell, set the spell name\n//or say the spell doesn't exist.\n\nfunction setRangerSpell() {\n  className = rangerName;\n  if (actor.items.find(i => i.name === `${rangerSpell}`)) {\n    spellName = rangerSpell;\n    castSpell();\n  } else {\n    ui.notifications.error(\n      \"Selected actor does not have the \" + rangerSpell + \" spell.\"\n    );\n    console.log(\"Selected actor does not have the \" + rangerSpell + \" spell.\");\n    return null;\n  }\n}\n\n//If the class is warlock and has the hex spell set the spell name\n//if say the spell doesn't exist\n\nfunction setWarlockSpell() {\n  className = warlockName;\n  if (actor.items.find(i => i.name === `${warlockSpell}`)) {\n    spellName = warlockSpell;\n    castSpell();\n  } else {\n    ui.notifications.error(\n      \"Selected actor does not have the \" + warlockSpell + \" spell.\"\n    );\n    console.log(\"Selected actor does not have the \" + warlockSpell + \" spell.\");\n    return null;\n  }\n}\n\n//check whether the token is a ranger or warlock\n\nfunction checkSpell() {\n  if (actor.items.find(i => i.name === `${rangerName}`)) {\n    setRangerSpell();\n  } else if (actor.items.find(i => i.name === `${warlockName}`)) {\n    setWarlockSpell();\n  } else {\n    ui.notifications.error(\n      \"Please select a \" + rangerName + \" or \" + warlockName + \" token.\"\n    );\n    console.log(\n      \"Please select a \" + rangerName + \" or \" + warlockName + \" token.\"\n    );\n  }\n}\n\nasync function updateActor(updateToken, obj) {\n  await updateToken.actor.update(obj);\n}\n\n//If the flag exists call functions to move or remove if it doesn't exist\n// call function to cast the spell\n\nif (myToken.getFlag(flagScope, actorId)) {\n  alterMark();\n} else {\n  checkSpell();\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"tch2n3sDUiZTxqGM"}
