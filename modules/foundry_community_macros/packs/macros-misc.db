{"_id":"3byKEzTIX7jnn0DX","name":"Folder To Rollable Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Take the entries of a folder and turn it into a rollable table.\n// NOTE: you must click the \"Normalize Result Weights\" button (scale icon) after import.\n// Author: @Atropos#3814\n\n// name of folder whos entities you wish to push into a rollable table.\nconst folder = game.folders.getName(\"Herbalism & Alchemy\");\n// name of table you will be overwriting\nconst table = game.tables.getName(\"Common Ingredients\");\n// change this to match the entity type you are importing.\n// Actor, Item, Scene, JournalEntry, Macro, RollTable, Playlist\nconst entityType = \"Item\"\n\nconst items = folder.entities;\nconst results = folder.entities.map(i => {\n  return {\n    text: i.data.name,\n    type: 1,\n    collection: \"Item\",\n    resultId: i.data._id,\n    img: i.data.img,\n    weight: 1,\n    range: [1, 1],\n    drawn: false\n  }\n});\nawait table.createEmbeddedEntity(\"TableResult\", results);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"525JVjJGyjIH5gv2","name":"Log Troubleshooting MSG To Console","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @fohswe\n// Logs a troubleshooting message to the browser console.\n// (You can usually view the browser console using F12.)\n\nconst gl = canvas.app.renderer.context.gl;\n\nconsole.log(\n`=== Start of troubleshooting ===\nBackground image: ${canvas.background.img.width}x${canvas.background.img.height}\nNumber of walls: ${canvas.scene.data.walls.length}\nNumber of selected vision sources: ${canvas.sight.sources.vision.size}\nNumber of light sources: ${canvas.sight.sources.lights.size}\nWebGL MAX_TEXTURE_SIZE: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}\n`\n);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Polygon Drawing To Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Converts selected polygon drawing to a wall\n * @Author: cole#9640\n */\n\nlet drawings = canvas.drawings.controlled;\n\ndrawings = drawings.filter(drawing =>  {\n    if (!drawing.isPolygon) {\n        ui.notifications.warn(`Drawing \"${drawing.data._id}\" is not a polygon, skipping`);\n        return false;\n    }\n    return true;\n});\n\nif (drawings.length) {\n    const newWalls = drawings.flatMap((drawing) => {\n        const { x, y, width, height } = drawing.data;\n        const xCenterOffset = width/2;\n        const yCenterOffset = height/2;\n        \n        const θ = toRadians(drawing.data.rotation);\n        const cosθ = Math.cos(θ);\n        const sinθ = Math.sin(θ);\n        \n        const points = drawing.data.points.map((point) => {\n            const offsetX = point[0] - xCenterOffset;\n            const offsetY = point[1] - yCenterOffset;\n            const rotatedX = (offsetX * cosθ - offsetY * sinθ);\n            const rotatedY = (offsetY * cosθ + offsetX * sinθ);\n            return [rotatedX + x + xCenterOffset, rotatedY + y + yCenterOffset];\n        });\n        \n        return points.slice(0, points.length - 1)\n            .map((point, i) => {\n                return { c: point.concat(points[i + 1]) };\n            });\n    });\n    \n    canvas.scene.createEmbeddedEntity(\"Wall\", newWalls);\n    canvas.walls.activate();\n} else {\n    ui.notifications.error(\"No polygon drawings selected!\");\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"5LiZJnGQpu0g9mB0"}
{"_id":"5XA28twwaRBUFEjC","name":"Breathing Lights","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @ohporter\n// Cause lightsources to \"breathe,\" expanding and contracting.\n(async () => {\n    let min = 5;\n    let max = 10;\n    if (game.pulsatingLights) {\n      game.pulsatingLights = false;\n    } else {\n      game.pulsatingLights = true;\n      let glyphLights = [];\n      let glyphColor = \"#5940b5\"\n      let scene = game.scenes.active;\n  \n      canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === glyphColor && l.scene === scene) glyphLights.push(l.id) })\n  \n      const updates = []\n  \n      let radius = min;\n      let increment = true;\n      let interval = setInterval(async () => {\n        glyphLights.forEach(id => {\n          updates.push({ _id: id, dim: radius, bright: radius/2});\n        })\n        await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n  \n        if (increment) {radius += 1} else {radius -= 1};\n        if (radius === max) {increment = false};\n        if (radius === min) {increment = true};\n        if (!scene.active || !game.pulsatingLights) {\n          // Reset to default glow\n          glyphLights.forEach(id => {\n            updates.push({ _id: id, dim: min, bright: 0});\n          })\n          await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  })()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"8iEx21HSVOmkbBFE","name":"Combat Tracker AC HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Adds the actor's AC to the combat tracker. Then toggles between HP and AC\nconst a = \"attributes.ac.value\";\nconst b = \"attributes.hp.value\";\n\nif (game.combat.settings.resource == a) {\n  game.settings.set('core', 'combatTrackerConfig', {resource: b, skipDefeated: true});\n} else {\n  game.settings.set('core', 'combatTrackerConfig', {resource: a, skipDefeated: true});\n}\nui.combat.updateTrackedResources();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Equip Unequip Shield","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Equips/unequips an item. Make sure you change the variables at the top (as required).\n * This script will also error check to make sure items exist and tokens are select. \n * Chat and token icon display options can be set as desired.\n * Author: Zapgun\n */\n\nlet itemName = 'Shield'; // <--- Change this to the *exact* item name (capitals count!)\nlet sendToChat = true; // <--- Change to 'true' or 'false' to display a chat message about equipping\nlet displayIcon = true; // <--- Change to 'true' or 'false' to display an effect icon when equipped\nconst effectIconPath = 'icons/svg/shield.svg'; // <--- Add the effect icon you want to appear when equipped\n\nlet toggleResult = false;\n\nif (!actor) {\n    ui.notifications.warn('You need to select a token before using this macro!');\n} else {\n\n\tlet myItem = actor.items.find(i => i.name == itemName);\n\tif (myItem != null)\n\t{\n\t\tlet item = actor.getOwnedItem(myItem._id);\n\t\tlet attr = \"data.equipped\";\n\t\tlet equipped = getProperty(item.data, attr);\n\t\tif (sendToChat) {\t\t\t\n\t\t\tif (!equipped) {\n\t\t\t\tchatMessage(actor.name + ' <b>equips</b> their <i>' + ' ' + itemName+ '</i>');\n\t\t\t} else {\n\t\t\t\tchatMessage(actor.name + ' <b>un-equips</b> their <i>' + ' ' + itemName + '</i>');\t\t\t\n\t\t\t}\n\t\t}\n\t\titem.update({[attr]: !getProperty(item.data, attr)});\n\t\t\n\t\t// mark/unmark character's token with an effect icon when displayToken is true\n\t\t(async () => { \n\t\t\tif (displayIcon) {\n\t\t\t\ttoggleResult = await token.toggleEffect(effectIconPath);\n\t\t\t\tif (toggleResult == equipped) token.toggleEffect(effectIconPath);  \n\t\t\t}\n\t\t})();\n\t\t\n\t} else {\n\t\tui.notifications.warn(\"No item named '\" + itemName + \"' found on character!\");\n\t}\n}\n\nfunction chatMessage(messageContent) {\n\t// create the message\n\tif (messageContent !== '') {\n\t\tlet chatData = {\n\t\t\tuser: game.user._id,\n\t\t\tspeaker: ChatMessage.getSpeaker(),\n\t\t\tcontent: messageContent,\n\t\t};\n\t\tChatMessage.create(chatData, {});\n\t}\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"BqcD9aq88kWU67Uf"}
{"name":"Announce Round Number","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.V1p6LWoKnv7croAd"}},"scope":"global","command":"let messageContent = `<hr><div style=\"color: black; font-size: 1.75em; font-weight: bold;\">ROUND ${game.combat.round}</div><hr>`\nChatMessage.create({content: messageContent});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"CVbowNiiiwqmADGY"}
{"_id":"Cp6zQmvC9KSCEo1s","name":"Toggle Playlist","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// get actual pl data from entries\nlet _playlistArray = game.playlists.entries;\nlet _applyChanges = false;\nlet _raw = `\n\n<form>\n    <div class=\"form-group\">\n        <label>Select Playlist:</label>\n        <select id=\"playlist-selection\" name=\"playlist-selection\">\n        {{#each this}}\n            <option> {{this.data.name}} </option>\n        {{/each}}\n        </select>\n    </div>\n</form>\n`\nlet _html = Handlebars.compile(_raw)\nlet d = new Dialog({\n    title: \"Playlist Toggle\",\n    content: _html(_playlistArray),\n    buttons: {\n        toggle: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"Toggle Selected Playlist\",\n            callback: () => _applyChanges = true\n        },\n    },\n    default: \"toggle\",\n    close: html => {\n        if (_applyChanges) {\n            let _plName = html.find('[name=\"playlist-selection\"]')[0].value || \"none\";\n            let _pl = game.playlists.getName(_plName);\n            if (_pl.playing) {\n                // turn off\n                _pl.stopAll();\n            } else {\n                // turn on\n                _pl.playAll();\n            }\n        }\n    }\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"GhloAVkE0qJJGyoB","name":"Award Party XP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"(function ()\n{\n  function award_xp(type, amount)\n  {\n    let actors = game.actors.entities.filter(e => e.data.type === 'character' && e.isPC);\n    let isShared = type == \"shared\";\n    console.log(type + ' ' + amount);\n    if (Number.isInteger(amount) && actors.length > 0)\n    {\n      let totalAmount = isShared ? amount : amount * actors.length;\n      let individualAmount = isShared ? Math.floor(amount / actors.length) : amount\n\n      let chatContent = `\n\t\t\t<b>${totalAmount} Experience Awarded!</b>\n\t\t\t<br>${individualAmount} added to:\n\t\t\t`;\n\n      actors.forEach(actor =>\n      {\n        chatContent += `<br>${actor.name}`;\n        actor.update({\n          \"data.details.xp.value\": actor.data.data.details.xp.value + individualAmount\n        });\n      });\n\n      let chatData = {\n        user: game.user._id,\n        speaker: ChatMessage.getSpeaker(),\n        content: chatContent,\n        type: CONST.CHAT_MESSAGE_TYPES.OTHER\n      };\n      ChatMessage.create(chatData);\n    }\n  }\n\n  new Dialog({\n    title: \"Award Party XP\",\n    content: `\n     <p>Select a type and an amount. Individual xp will give or take a set amount to/from each party member, whereas shared will split an amount evenly.</p>\n     <form>\n      <div class=\"form-group\">\n       <label>Type:</label>\n       <select id=\"xp-type\">\n        <option value=\"individual\">individual</option>\n        <option value=\"shared\">shared</option>\n       </select>\n      </div>\n      <div class=\"form-group\">\n       <label>Amount</label>\n       <input type=\"text\" inputmode=\"numeric\" pattern=\"\\d*\" id=\"xp-amount\">\n      </div>\n     </form>\n     `,\n    buttons: {\n      one: {\n        icon: '<i class=\"fas fa-check\"></i>',\n        label: \"Confirm\",\n        callback: (html) =>\n        {\n          let type = html.find('[id=xp-type]')[0].value;\n          let amount = parseInt(html.find('[id=xp-amount]')[0].value);\n          award_xp(type, amount);\n        }\n      },\n      two: {\n        icon: '<i class=\"fas fa-times\"></i>',\n        label: \"Cancel\",\n      }\n    },\n    default: \"Cancel\"\n  }).render(true);\n})();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"JV1pRTUy2LuaAh0L","name":"Folder to Compendium","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Import folder into writable compendium. Locked compendiums will not show as an option.\n * Folder type is optional, however will help if you have the same folder name across multiple system types.\n * Also contains options to store subfolder contents, update existing records (or only add new), and delete duplicate records.\n * Author: KrishMero#1792\n */\n\nlet packOptions = game.packs.filter(pack => !pack.locked).map(pack => `<option value=\"${pack.collection}\">${pack.title}</option>`);\nlet entityType = COMPENDIUM_ENTITY_TYPES.map(type => `<option value=\"${type}\">${type}</option>`);\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Folder Type:</div>\n  <select id=\"entityType\" />\n    <option value=\"\">--</option>\n    ${entityType}\n  </select>\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Compendium:</div>\n  <select id=\"destinationPack\" />\n    ${packOptions}\n  </select>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"recurse\" checked/>\n    Store subfolders too\n  </label>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"update\" checked/>\n    Update existing records (unchecked = only add new)\n  </label>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"delete\" checked/>\n    Delete duplicates\n  </label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Store folder in compendium\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply\",\n      callback: storeFolder\n    }\n  }\n}).render(true);\n\nfunction storeFolder(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const folderType = html.find(`select#entityType`)[0].value;\n  const destinationPack = html.find(`select#destinationPack`)[0].value;\n  const recurse = html.find(`input#recurse`)[0].checked;\n  const update = html.find(`input#update`)[0].checked;\n  const deleteRecords = html.find(`input#delete`)[0].checked;\n  \n  let folders = game.folders.filter(f => f.name === folderName);\n  if (folderType) {\n    folders = folders.filter(f => f.type === folderType);\n  }\n  if (folders.length === 0) {\n    ui.notifications.error(`Your world does not have any folders named '${folderName}'.`);\n  }\n  else if(folders.length > 1) {\n    ui.notifications.error(`Your world has more than one folder named ${folderName}`) \n  }\n  else {\n    console.log(`storing in ${destinationPack}`);\n    let packObject = game.packs.get(destinationPack);\n    storeRecursively(folders[0], packObject, recurse, update, deleteRecords);\n    ui.notifications.notify(`'${folderName}' stored successfully in '${packObject.title}'.`);\n  }\n}\n\nfunction storeRecursively(currentFolder, packObject, recurse, update, deleteRecords) {\n  console.log('store recursively for ' + currentFolder.name);\n  if (currentFolder.content) {\n    currentFolder.content.map(item => {\n      console.debug(\"  Item:\", item.data.name);\n      let existingRecords = packObject.index.filter(i => i.name === item.data.name);\n      if (item.data.name === 'Augury') {\n        console.log(existingRecords);\n        console.log(existingRecords.length);\n      }\n\n      // Delete all but the first duplicate.\n      if(existingRecords.length > 1) {\n        if (deleteRecords) {\n          console.log(existingRecords);\n          existingRecords.shift();\n          existingRecords.map(record => packObject.deleteEntity(record._id));\n        } else {\n          console.log(`Skipped: ${existingRecords[0].name}`)\n          ui.notifications.error(`Can't store '${existingRecords[0].name}' as multiple records were found. Delete the extras or check 'Delete duplicates'. Logged to console.`);\n        }\n      }\n\n      if (existingRecords.length === 1 && update) {\n        packObject.updateEntity(existingRecords[0]);\n      } else if (!existingRecords.length) {\n        packObject.createEntity(item);\n      }\n      \n    });\n  }\n\n  if (currentFolder.children && recurse) {\n    currentFolder.children.map(({ data }) => {\n      storeRecursively(\n        game.folders.entities.filter(f => f.data._id == data._id)[0],\n        packObject,\n        recurse, \n        update,\n        deleteRecords\n      );\n    });\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"PJVvR31x5PNkdWFr","name":"Close All Doors","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"/**\n * Closes all doors on the canvas\n * Author: @Atropos#3814\n */\n \ncanvas.walls.updateMany(canvas.scene.data.walls.map(w => {\n  return {_id: w._id, ds: w.ds === 1 ? 0 : w.ds};\n}));\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Whisper Players","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/** \n * Provides a dialog to whisper specific players. If you have tokens selected, it will automatically default to try and whisper those players.\n * @Author: Nelson#3570\n */\n\nlet applyChanges = false;\n\nlet users = game.users.filter(user => user.active);\nlet checkOptions = \"\"\nlet playerTokenIds = users.map(u => u.character?.id).filter(id => id !== undefined);\nlet selectedPlayerIds = canvas.tokens.controlled.map(token => {\n  if (playerTokenIds.includes(token.actor.id)) return token.actor.id;\n});\n\n// Build checkbox list for all active players\nusers.forEach(user => {\n  let checked = !!user.character && selectedPlayerIds.includes(user.character.id) && 'checked';\n  checkOptions+=`\n    <br>\n    <input type=\"checkbox\" name=\"${user.id}\" value=\"${user.name}\" ${checked}>\\n\n    <label for=\"${user.id}\">${user.name}</label>\n  `\n});\n\nnew Dialog({\n  title:\"Whisper\",\n  content:`Whisper To: ${checkOptions} <br>\n    <label for=\"message\">Message:</label>\n    <textarea id=\"message\" name=\"message\" rows=\"4\" cols=\"50\"></textarea><br>`,\n  buttons:{\n    whisper:{   \n      label:\"Whisper\",\n      callback: (html) => createMessage(html)\n    }\n  }\n}).render(true);\n\nfunction createMessage(html) {\n  var targets = [];\n  // build list of selected players ids for whispers target\n  for ( let user of users ) {\n    if (html.find('[name=\"'+user.id+'\"]')[0].checked){\n      targets.push(user.id);\n    }\n    var messageText = html.find('[name=\"message\"]')[0].value\n  }\n\n  ChatMessage.create({\n    content: messageText,\n    whisper: targets\n  });\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"QTDeg4HOYCAmr4dK"}
{"_id":"VXTRsUfomoFN9PVP","name":"Folder Permission","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Provides a prompt to set global permissions to all items within a folder.\n// Prompts the user for the folder name (case sensitive) and the permission level.\n\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Permission:</div>\n  <select id=\"desiredPermission\" />\n    <option value=\"0\">None</option>\n    <option value=\"1\">Limited</option>\n    <option value=\"2\">Observer</option>\n    <option value=\"3\">Owner</option>\n  </select>\n  <br />\n\n  <label>\n  \t<input type=\"checkbox\" id=\"recurse\" checked/>\n    Recurse into subfolders\n\t</label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Set desired permission\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply permissions\",\n      callback: applyPermissions\n    }\n  }\n}).render(true);\n\nfunction applyPermissions(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const permission = html.find(`select#desiredPermission`)[0].value;\n  const recurse = html.find(`input#recurse`)[0].checked;\n  \n  const folders = game.folders.filter(f => f.name === folderName);\n  if (folders.length === 0) {\n    ui.notifications.error(`Your world does not have any folders named '${folderName}'.`);\n  }\n  else if(folders.length > 1) {\n   ui.notifications.error(`Your world has more than one folder named ${folderName}`) \n  }\n  else {\n    repermission(folders[0], permission, recurse);\n    ui.notifications.notify(`Desired permissions were set successfully for  '${folderName}'.`);\n  }\n}\n\nfunction repermission(currentFolder, desiredPermission, recurse) {\n  console.debug(\"Repermissioning: \", currentFolder.name);\n  \n  if (currentFolder.content) {\n    currentFolder.content.map(item => {\n      let newPermissions = duplicate(item.data.permission);\n      newPermissions.default = desiredPermission;\n      console.debug(\"  Item:\", item.data.name);\n      item.update({ permission: newPermissions });\n    });\n  }\n\n  if (currentFolder.children && recurse) {\n    currentFolder.children.map(({ data }) => {\n      repermission(\n        game.folders.entities.filter(f => f.data._id == data._id)[0],\n        desiredPermission,\n        recurse);\n    });\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Lock and Unlock Players","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.VhzAqG5Abes21JD9"}},"scope":"global","command":"async function updateRoles(from, to) {\n    game.users.entities.filter(u => u.role === from).forEach(u => u.update({role:to}))\n}\nnew Dialog({\n    title: `Lock or unlock all players?`,\n    default: 'cancel',\n    buttons: {\n        unlock: {\n            icon: '<i class=\"fas fa-unlock\"></i>',\n            label: 'Unlock',\n            callback: () => updateRoles(CONST.USER_ROLES.NONE, CONST.USER_ROLES.PLAYER)\n        },\n        lock: {\n            icon: '<i class=\"fas fa-lock\"></i>',\n            label: 'Lock',\n            callback: () => updateRoles(CONST.USER_ROLES.PLAYER, CONST.USER_ROLES.NONE)\n        },\n        cancel: {\n            icon: '<i class=\"fas fa-eject\"></i>',\n            label: 'Cancel',\n            callback: () => {}\n        }\n    }\n}).render(true)","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"Vhj3ctf5cAufQMnM"}
{"name":"Scene Border Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"for (let scene of game.scenes){\n  //Goes through the array of scenes and finds the active one.\n    if(scene.active == true){\n        //Height, Width, and Padding offsets. \n        //scene data.height and scene.data.width give image size.\n        //canvas dimensions give size including padding\n        //xf, yf = x and y offsets.\n        let h = scene.data.height;\n        let w = scene.data.width;\n        let xf = (canvas.dimensions.width - w)*0.5;\n        let yf = (canvas.dimensions.height - h)*0.5;\n        //Walls need two vertices: X Point 1, Y Point 1, X Point 2, Y Point 2\n        //top wall, right wall, bottom wall, left wall\n        let tw = [xf, yf, w + xf, yf];\n        let rw = [w + xf, yf, w + xf, h + yf];\n        let bw = [w + xf, h + yf, xf, h + yf];\n        let lw = [xf, h + yf, xf, yf];\n        //Creates walls. There is probably a cleaner way to do this.\n        Wall.create({\n            c: tw\n        });\n        Wall.create({\n            c: rw\n        });\n        Wall.create({\n            c: bw\n        });\n        Wall.create({\n            c: lw\n        });\n    }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"XIQjNhEFdzPA1mQY"}
{"_id":"XNQSxkffgHApZf4A","name":"Import from Compendium","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/** \n * Import all the entries from a compendium into the desired folder.\n * @Author: KrishMero#1702\n */\n \nlet packOptions = game.packs.map(pack => `<option value=\"${pack.collection}\">${pack.title}</option>`);\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n  <div style=\"font-size: 80%\">leave blank to create a folder after the compendium name</div>\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Compendium:</div>\n  <select id=\"destinationPack\" />\n    ${packOptions}\n  </select>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"delete\"/>\n    Clear destination first\n  </label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Import data from compendium\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply\",\n      callback: importCompendium\n    }\n  }\n}).render(true);\n\nasync function importCompendium(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const packName = html.find(`select#destinationPack`)[0].value;\n  const remove = html.find(`input#delete`)[0].checked;\n\n  const pack = game.packs.get(packName);\n  const entity = pack.entity;\n  let folder = folderName ? findFolder(folderName, entity) : await createFolder(pack, entity);\n  \n  if (!folder) return ui.notifications.error(`Your world does not have any ${entity} folders named '${folderName}'.`);\n\n  if (remove) removeDataFirst(folder.id, entity);\n  if (folder) importPack(pack, entity, folder.id)\n}\n\nasync function importPack(pack, entity, folderId) {\n  const entityClass = CONFIG[entity].entityClass;\n  const content = await pack.getContent();\n\n  const createData = content.map(c => {\n    c.data.folder = folderId;\n    return c.data;\n  });\n  entityClass.create(createData);\n}\n\nfunction removeDataFirst(folderId, entity) {\n  let type = getEntityType(entity);\n  const removeableData = game[type].filter(t => t.data.folder === folderId);\n  if (typeof removeableData.delete !== \"undefined\") {\n    removeableData.delete();\n  } else {\n    removeableData.map(d => d.delete());\n  }\n}\n\nasync function createFolder(pack, type) {\n  let name = pack.metadata.label;\n  let folder = await Folder.create({ name, type, parent: null});\n  return folder;\n}\n\nfunction findFolder(folderName, entity)\n{\n  return game.folders.find(f => f.name === folderName && f.type === entity)\n}\n\nfunction getEntityType(entity) {\n  switch (entity) {\n    case 'JournalEntry': return 'journal';\n    case 'RollTable': return 'tables';\n    default: return entity.toLowerCase() + 's';\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Tile XY Adjust","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//Simple macro to loop through ALL SELECTED TILES and adjust their position by a set amount\n\n//Questions? Ask in Foundry VTT Discord #macro-polo channel. If absolutely needed, ping @Norc$5108\n\nasync function adjustTileXY(tile, xAdjust, yAdjust ) {\n    await tile.update({\n        x: tile.x + xAdjust,\n        y: tile.y + yAdjust,\n    });\n}\n\n//check to make sure at least one tile is selected\nif (canvas.tiles.controlled[0]) {\n    //loop through all selected tiles\n    for (let t of canvas.tiles.controlled) {\n        //REPLACE THE \"1\" VALUES BELOW AS NEEDED\n            //The first number controls side-to-side position:\n                //Positive values move tiles to the right\n                //Negative values move tiles to the left\n                //If you enter 0, tiles will not move side to side at all.\n            //The second number controls up-and-down position:\n                //Positive values move tiles down\n                //Negative values move tiles up\n                //If you enter 0, tiles will not move up or down at all.\n        adjustTileXY(t, 1, 1);\n    }\n} else {\n    ui.notifications.notify(\"Please select at least one tile.\");\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"bD3UuA4ikwbCwtKX"}
{"_id":"bRBhm24NyQELbDti","name":"Create Chat Message","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @errational\n// Creates a chat message.\nconst content = `<p>Monster attacks ${controlledToken.name}</p>`;\n\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker(controlledToken),\n  content: content,\n  type: CONST.CHAT_MESSAGE_TYPES.OTHER\n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Delete All Templates","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Deletes all templates on the current scene\n */\n \n// no dialog. Just delete all templates.\ncanvas.templates.deleteMany(canvas.templates.placeables.map(o =>o.id),{});\n\n// Get a dialog confirmation before deleting all templates on the scene:\n// canvas.templates.deleteAll()\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"cbvoXlwrSGOFFybV"}
{"_id":"dgSOPUXWUK1701PV","name":"Find Lights By Color","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @FloRad\n// Right here's a macro that looks for lights of a certain color, \n// sets a different color and then logs out the ids of the \n// lights it previously found using the marker color\n(async () => {\n    let foundLights = [];\n    let markingColor = \"#00ff00\"\n    let newColor = \"#bbb\"\n    let scene = game.scenes.active;\n\n    canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === markingColor && l.scene === scene) foundLights.push(l.id) })\n\n    const updates = []\n    foundLights.forEach(id => {\n        updates.push({ _id: id, tintColor: newColor });\n    })\n\n    await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n\n    console.log(foundLights)\n})()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"e25oI8hASMY8bgu6","name":"Hex Crawler Helper","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nRequired Rollable Tables:\n*Wilderness Encounters*\n    coast\n    jungle1\n    jungle2\n    jungle3\n    mountains\n    rivers\n    ruins\n    swamp\n    wasteland\n\n*Other Tables*\n    weather\n    directions\n\n    cache\n    deadexplorers\n\nCache and Deadexplorers are not mandatory, but if you don't want them search the file for // CACHE LINES or // DEAD EXPLORER LINES and comment out the 2 lines below the comments\n\nExplanation of those tables:\nIf you have an encounter table that has the word cache in it, the cache table will be rolled automatically.\n    <br/><span id=\"cache\">The party finds a cache: </span>\nIf you have an encounter table that has DeadExplorers in it, the dead explorer table will be rolled automatically.\n    <br/><span id=\"DeadExplorers\">The party finds: </span> \n\n\nYou can have an automatic moving \"Actual Location\" Marker by creating a Token named \"Actual Location\" and placing it on your hex grid.\nThis will move if the players are \"Lost\". If the players are not lost it will not move.\n\n\n\n*/\n\n\n// Macro requires selecting a token to roll the survival check\n\nlet hexCrawl() => {\n    if (canvas.tokens.controlled.length === 0)\n        return ui.notifications.error(\"Please select the token of the Navigator!\");\n\n    const playerMarker = canvas.scene.data.tokens.find(a => a.name === 'Player Location');\n    const locationMarker = canvas.scene.data.tokens.find(a => a.name === 'Actual Location');\n\n    const gridSize = canvas.grid.size;\n    const vertical = gridSize * 0.866666;\n    const diagVertical = gridSize * 0.433333;\n    const diagHorizontal = gridSize * 0.75;\n\n    // The option values below are the names of your rollable tables for each hex type. If these get changed here you will need to change them in the Survival Check DC section too!\n\n    let pace = 'none';\n    new Dialog({\n        title: `Hex Crawl Helper`,\n        content: `\n        <form>\n            <div class=\"form-group\">\n                <label>Hex Type:</label>\n                <select id=\"hex-type\" name=\"hex-type\">\n                    <option value=\"coast\">Coast</option>\n                    <option value=\"jungle1\">Jungle: No Undead</option>\n                    <option value=\"jungle2\">Jungle: Lesser Undead</option>\n                    <option value=\"jungle3\">Jungle: Greater Undead</option>\n                    <option value=\"mountains\">Mountains</option>\n                    <option value=\"rivers\">River</option>\n                    <option value=\"ruins\">Ruins</option>\n                    <option value=\"swamp\">Swamp</option>\n                    <option value=\"wasteland\">Wasteland</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Direction:</label>\n                <select id=\"travel-direction\" name=\"travel-direction\">\n                    <option value=\"North\">North</option>\n                    <option value=\"Northeast\">Northeast</option>\n                    <option value=\"Southeast\">Southeast</option>\n                    <option value=\"South\">South</option>\n                    <option value=\"Southwest\">Southwest</option>\n                    <option value=\"Northwest\">Northwest</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Type:</label>\n                <select id=\"travel-type\" name=\"travel-type\">\n                    <option value=\"on-foot\">On Foot</option>\n                    <option value=\"canoe\">By Canoe</option>\n                </select>\n            </div>\n        </form>\n        `,\n        buttons: {\n            slow: {\n                icon: \"<i class='fas fa-user-ninja'></i>\",\n                label: `Slow Pace`,\n                callback: () => pace = 'slow'\n            },\n            average: {\n                icon: \"<i class='fas fa-hiking'></i>\",\n                label: `Average Pace`,\n                callback: () => pace = 'average'\n            },\n            fast: {\n                icon: \"<i class='fas fa-running'></i>\",\n                label: `Fast Pace`,\n                callback: () => pace = 'fast'\n            }\n        },\n        default: \"average\",\n        close: html => {\n            // set variables\n            let hexType = html.find('[name=\"hex-type\"]')[0].value;\n            let travelType = html.find('[name=\"travel-type\"]')[0].value;\n            let playerDirection = html.find('[name=\"travel-direction\"]')[0].value;\n            const weatherTable = game.tables.entities.find(t => t.name === \"weather\");\n            const directionTable = game.tables.entities.find(t => t.name === \"directions\");\n            const cacheTable = game.tables.entities.find(t => t.name === \"cache\");\n            const deadExplorerTable = game.tables.entities.find(t => t.name === \"deadexplorers\");\n            const encounterTable = game.tables.entities.find(t => t.name === hexType);\n            let weatherRoll = weatherTable.roll()[1].text;\n            let lostDirection = directionTable.roll()[1].text;\n            let msgContent = '<strong>Weather</strong> ' + weatherRoll + '<br/><br/>';\n            let navigator = Actors.instance.get(canvas.tokens.controlled[0].data.actorId);\n            let wis = navigator.data.data.abilities.wis.mod;\n            let survival = new Roll(`1d20`).roll().total + wis;\n            let slowPace = new Roll(`1d4`).roll().total;\n            let fastPace = new Roll(`1d2`).roll().total;\n            let hexesMoved = 1;\n            let encounter = '';\n            let hexText = 'hexes';\n\n            if (travelType === 'canoe') {\n                hexesMoved++;\n            }\n\n            // build pace message and hex movement\n            if (pace === 'slow') {\n                if (slowPace === 1)\n                    hexesMoved--;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Slow pace:</strong> Can hide from encounters or approach stealthily.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival += 5;\n            } else if (pace === 'average') {\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Average pace:</strong> For rivers, upstream and downstream have no effect, and waterfalls occur every 10 to 20 miles (requiring portage of canoes).<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n            } else if (pace === 'fast') {\n                if (fastPace === 1)\n                    hexesMoved++;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Fast pace:</strong> -5 to passive Perception.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival -= 5;\n            } else {\n                return;\n            }\n\n            // Survival Check DC for each hex type. If selected token rolls under DC the party is lost!\n            if (((hexType === 'coast' || hexType === 'ruins') && survival < 10) || ((hexType === 'jungle1' || hexType === 'jungle2' || hexType === 'jungle3' || hexType === 'mountains' || hexType === 'rivers' || hexType === 'swamp' || hexType === 'wasteland') && survival < 15)) {\n                msgContent += '<strong>Party is Lost:</strong> Move actual location ' + hexesMoved + ' ' + hexText + ' to the ' + lostDirection + '<br/><br/>';\n                if (locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker._id);\n                    switch (lostDirection) {\n                        case 'South':\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n                if (playerMarker) {\n                    const playerToken = canvas.tokens.get(playerMarker._id);\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.update({\n                                x: playerToken.x,\n                                y: playerToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.update({\n                                x: playerToken.x,\n                                y: playerToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            } else {\n                if (playerMarker && locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker._id);\n                    const playerToken = canvas.tokens.get(playerMarker._id);\n\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            msgContent += '<strong>Morning Encounter:</strong> ';\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n                msgContent += '<strong>Afternoon Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Afternoon Encounter:</strong> ';\n            }\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n                msgContent += '<strong>Evening Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Evening Encounter:</strong> ';\n            }\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n            } else {\n                msgContent += 'None.';\n            }\n\n            // create the message\n            let chatData = {\n                content: msgContent,\n                whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n            };\n            ChatMessage.create(chatData, {});\n        }\n    }).render(true);\n}\n\nhexCrawl();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"fYT65nJz51J74ymJ","name":"Jukebox","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Quickly play from a list of sound effects and set their audio level. (does not loop)\n * Author: Rockshow\n */\n\nlet playlist = {\n  'twigs breaking': 'audio/twigs_1.mp3',\n  'door opening': 'sounds/lock.wav',\n};\n\nlet optionList;\nfor (let [key, value] of Object.entries(playlist)) {\n  optionList += `<option value=\"${value}\">${key}</option>`;\n}\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Audio chosing form`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Canzone:</label>\n        <select id=\"idcanzone\" name=\"idcanzone\">\n          ${optionList}\n        </select>\n      </div>\n   \n        <div class=\"form-group\">\n        <label for=\"vol\">Volume:</label>\n           <div class=\"form-fields\">\n            <input type=\"range\" id=\"vol\" name=\"vol\" min=\"0\" max=\"8\" value=\"1\" step=\"0.2\" data-dtype=\"Number\">\n            <span class=\"range-value\" id=\"demo\">1</span>\n           </div>\n        </div>\n </form> \n<script>\nvar slider = document.getElementById(\"vol\");\nvar output = document.getElementById(\"demo\");\noutput.innerHTML = slider.value;\n\nslider.oninput = function() {\n  output.innerHTML = this.value;\n}\n</script>\n          `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n        },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n         },\n           },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n    let canzone= html.find('[name=\"idcanzone\"]')[0].value || \"none\";\n    let vol1= html.find('[name=\"vol\"]')[0].value || \"none\";\n    AudioHelper.play({src: canzone, volume:vol1, autoplay: true, loop: false}, true);\n                      }\n                 }\n  }).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"fdXN3rcX29ZkRRL2","name":"Tile Toggle Locked Status","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//Simple macro to loop through ALL SELECTED TILES and toggle their locked status.\n//In other words:\n    //If an individual tile is unlocked, this macro will lock it.\n    //If an individual tile is locked, this macro will unlock it.\n\nif (canvas.tiles.controlled[0]) {\n    canvas.tiles.controlled.forEach(tile => {\n        tile.update({ locked: !tile.data.locked});\n    });\n} else {\n    ui.notifications.notify(\"Please select at least one tile.\");\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Scale Grid Size To Inches","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\nAuthor: @stan#1549 (github.com/janssen-io)\n\nDescription:\nThe first time you click the macro, it will prompt you for your screen size (diagonal).\nClicking the macro a second time will automatically scale to 1\"/grid unit (square/hex).\nShift-click the macro to update this value.\n\nNote:\nThe screen size is saved per client. So opening the macro on another device for the first time, will make it prompt for the screen size again.\n */\n\nfunction showDialog(inches, resolve) {\n  new Dialog({\n    content: `Screen size (inches): <input type=\"number\" min=\"10\" max=\"200\" value=\"${inches}\" />`,\n    default: 'scale',\n    buttons: {\n      scale: {\n        label: 'Scale',\n        callback: html => resolve(+html.find('input').val())\n      }\n    }\n  }).render(true);\n}\n\nfunction scale(screenSizeInches) {\n  const diagonal = Math.sqrt(screen.width ** 2 + screen.height ** 2);\n  const ppi = diagonal / screenSizeInches;\n  console.log(`PPI: ${screenSizeInches}\" screen | ${canvas.grid.size}px per grid unit | ${ppi}px per inch | Scaling to: ${ppi / canvas.grid.size}`);\n  canvas.animatePan({ scale: ppi / canvas.grid.size });\n}\n\nconst key = 'stan#1549.scale.screenSize';\nconst storedScreenSize = localStorage.getItem(key);\nconst shouldUpdatePPI = !storedScreenSize || event.shiftKey;\n\nconst getScreenSize = new Promise(resolve => {\n  if (shouldUpdatePPI) {\n    showDialog(storedScreenSize || 42, resolve);\n  } else {\n    resolve(storedScreenSize);\n  }\n});\n\ngetScreenSize.then(inches => {\n  scale(inches);\n  localStorage.setItem(key, inches);\n});\n\n\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"gq8UDK94ykfMViNT"}
{"_id":"iLlJKBjrtOMNxlv6","name":"Tile Toggle Hidden Status","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Simple macro to loop through ALL SELECTED TILES and toggle whether or not they are hidden.\n// Uncomment line 8 or 9 to change behavior to hide / show all tiles instead of toggle\n\nif (canvas.tiles.controlled[0]) {\n  canvas.tiles.controlled.forEach(tile => {\n    let v;\n    v = !tile.data.hidden; // Toggle visibility for each tile\n    // v = false;          // Hide all selected tiles\n    // v = true;           // Show all selected tiles\n    tile.update({ hidden: v });\n  });\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Format All Scene Notes","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.yBeuLYd6wNuX6JHQ"}},"scope":"global","command":"let newNoteData = {};\n\nfor (let c of canvas.notes.children[0].children) {\n    //newNoteData = duplicate(c.data);\n\n    /*  \n        Define new note properties\n        double right-click a map pin for a list of valid fonts, icons, etc. \n        Remove the // in front of any line below to enable that change.    \n    */\n\n    //newNoteData.fontFamily = \"Signika\";\n    //newNoteData.fontSize = 8;\n    \n    /* \n        replace the name of the icon, for example, the anchor would be \"icons/svg/anchor.svg\" \n    */ \n    //newNoteData.icon = \"icons/svg/book.svg\";\n    //newNoteData.iconSize = 40;\n    //newNoteData.iconTint = \"\";\n    //newNoteData.text = \"test\";\n    \n    /*  \n        textAnchor controls the location of the text in relation to the icon. 0-4 are valid choices.\n        1 is the default, below. 0 hovers over the icon itself. 2 is above, 3 is left, 4 is right.  \n    */\n    //newNoteData.textAnchor = 1;\n    //newNoteData.textColor = \"#000000\";\n    //newNoteData.x = 2250;\n    //newNoteData.y = 2050;\n\n    c.update(newNoteData);\n\n}\n\nasync () => {\n    await canvas.draw()\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"lPEdDL4uqxRFfW9x"}
{"_id":"mPIqhwFL3h5W9d2t","name":"Share Image Via URL","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Share an image to all players when you have an image URL\n * Author: @Krishmero#1792\n */\n\nlet imagePopup = (imageUrl) => {\n\t// Display the image popout and share it.\n\tconst ip = new ImagePopout(imageUrl);\n\tip.render(true);\n\tip.shareImage();\n};\n\nlet chatDialog = (imageUrl) => {\n\tChatMessage.create({\n\t\tuser: game.user._id,\n\t\tcontent: `<img src=\"${imageUrl}\" />`,\n\t\ttype: CONST.CHAT_MESSAGE_TYPES.OOC\n\t});\n};\n\nlet selectOptions = game.user.isGM ? `\n<div style=\"display: inline-block; width: 100%; margin-bottom: 10px\">\n\t<label for=\"output-options\" style=\"margin-right: 10px\">Output Options:</label>\n\t<select id=\"output-options\" />\n\t\t<option value=\"popup\">Popup</option>\n\t\t<option value=\"chat\">Chat</option>\n\t\t<option value=\"both\">Both</option>\n\t</select>\n</div>\n<br />\n` : '';\n\nnew Dialog({\n\ttitle: `Share Image via URL`,\n\tcontent: `\n\t\t<form>\n\t\t\t${selectOptions}\n\t\t\t<div style=\"display: flex; width: 100%; margin-bottom: 10px\">\n\t\t\t\t<label for=\"image-url\" style=\"white-space: nowrap; margin-right: 10px; padding-top:4px\">Image URL:</label>\n\t\t\t\t<input type=\"text\" id=\"image-url\" name=\"image-url\" />\n\t\t\t</div>\n\t\t</form>\n\t`,\n\tbuttons: {\n\t\tyes: {\n\t\t\ticon: \"<i class='fas fa-check'></i>\",\n\t\t\tlabel: `Share`,\n\t\t\tcallback: (html) => {\n\t\t\t\tlet imageUrl = html.find('#image-url').val();\n\t\t\t\tlet permission = html.find('select#output-options')[0]?.value || null;\n\t\t\t\tif (!imageUrl) {\n\t\t\t\t\treturn ui.notifications.info(\"You did not provide a valid image.\");\n\t\t\t\t}\n\t\t\t\tif (game.user.isGM && ['popup', 'both'].includes(permission)) {\n\t\t\t\t\timagePopup(imageUrl);\n\t\t\t\t}\n\t\t\t\tif (!game.user.isGM || ['chat', 'both'].includes(permission)) {\n\t\t\t\t\tchatDialog(imageUrl);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tno: {\n\t\t\ticon: \"<i class='fas fa-times'></i>\",\n\t\t\tlabel: `Cancel`\n\t\t},\n\t},\n\tdefault: \"yes\"\n}).render(true)\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"mzkDNKmsOb9WwpIO","name":"Fine Tile Control","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Fine Tile Control //\n\n// This is a series of 6 macros that you must paste individually into a new\n// Hot Bar Macro Sheet and save. The Hot Bar number is used to activate the macro.\n// Hold down the Control key to halve the distance increment from 1 to 0.5.\n// CAUTION: If the ctrl key doesn‘t check your operating system and/or move the\n// macro to another cell.\n// NOTE: Any locked tiles are ignored.\n\n// Move Up\n// By @cole$9640\n\nlet amount = event.ctrlKey ? -0.5 : -1;\n\nif (canvas.tiles.controlled.length) {\n  const updates = canvas.tiles.controlled\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      y: tile.y + amount,\n    }));\n  canvas.tiles.updateMany(updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Down\n// By @cole$9640\n\nlet amount = event.ctrlKey ? 0.5 : 1;\n\nif (canvas.tiles.controlled.length) {\n  const updates = canvas.tiles.controlled\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      y: tile.y + amount,\n    }));\n  canvas.tiles.updateMany(updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Right\n// By @cole$9640\n\nlet amount = event.ctrlKey ? 0.5 : 1;\n\nif (canvas.tiles.controlled.length) {\n  const updates = canvas.tiles.controlled\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      x: tile.x + amount,\n    }));\n  canvas.tiles.updateMany(updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Left\n// By @cole$9640\n\nlet amount = event.ctrlKey ? -0.5 : -1;\n\nif (canvas.tiles.controlled.length) {\n  const updates = canvas.tiles.controlled\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      x: tile.x + amount,\n    }));\n  canvas.tiles.updateMany(updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Rotate Left\n// Original by @Norc$5108, updated and refined by @cole$9640 & @Drunemeton$7955\n\nlet amount = event.ctrlKey ? -0.5 : -1;\n\nif (canvas.tiles.controlled[0]) {\n  canvas.tiles.controlled.forEach((ti) => {\n    if (ti.data.locked) return;\n    let r = ti.data.rotation;\n    ti.update({ rotation: r + amount });\n  });\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Rotate Right\n// Original by @Norc$5108, updated and refined by @cole$9640 & @Drunemeton$7955\n\nlet amount = event.ctrlKey ? 0.5 : 1;\n\nif (canvas.tiles.controlled[0]) {\n  canvas.tiles.controlled.forEach((ti) => {\n    if (ti.data.locked) return;\n    let r = ti.data.rotation;\n    ti.update({ rotation: r + amount });\n  });\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"qlx6N8QD6QliPQbu","name":"Create Ambient Light","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Create a (pre-configured) lightsource on the current scene. \n// This example is a blue light for \"activating a stargate.\"\n\nAmbientLight.create({\n  t: \"l\", // l for local. The other option is g for global.\n  x: 1100, // horizontal positioning\n  y: 1150, // vertical positioning\n  dim: 20.50, // the total radius of the light, including where it is dim.\n  bright: 19.00, // the bright radius of the light\n  angle: 360, // the coverage of the light. (Try 30 for a \"spotlight\" effect.)\n  rotation: 0, // the beam direction of the light in degrees (if its angle is less than 360 degrees.) \n               // Oddly, degrees are counted from the 6 o'clock position.\n  tintColor: \"#0080FF\", // Light coloring.\n  tintAlpha: 0.5 // Light opacity (or \"brightness,\" depending on how you think about it.) \n});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"r8G0g61ikT9mJJwF","name":"Move Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/* From: @(Busy) Gen Kitty (she/her)\nTo move each node on both axes, you need all 4 parameters listed. \nIn this case, he wanted to move all the walls up and to the left and \nthe foundry grid is sorta vertically flipped to what you'd expect, \nwhich is why all of the operators are \"-=\" If you wanted to move them \nin different directions it'd just be a matter of changing the operator \nnext to the equals sign.\n\nEach argument is a node's X or Y position, and each wall segment has two nodes. \n0 = Node 1 X \n1 = Node 1 Y \n2 = Node 2 X \n3 = Node 2 Y\n*/\n\nlet walls = canvas.scene.data.walls.map(w => {\n  w = duplicate(w);\n  w.c[0] -= 50;\n  w.c[1] -= 50;\n  w.c[2] -= 50;\n  w.c[3] -= 50;\n  return w;\n});\ncanvas.scene.update({walls: walls});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ra2KPziISGyrVcK2","name":"Hide Video Boxes","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Hides the camera boxes.\n// Note: this has to be re-ran when the UI refreshes.\n\nlet cameras = document.getElementById(\"camera-views\");\ncameras.style.display = cameras.style.display === \"none\" ? \"flex\" : \"none\";\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Delete Items Not In Folders","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Clears the actors entity of any entries not in a folder.\n * Change 'actors' to another game entity such as tables, items, macros, etc... to clear items not in directory for those places.\n * Author: KrishMero#1792\n */\n \n game.actors.forEach(t => {\n  if (!t.data.folder) {\n    t.delete();\n  }\n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"rhnCyrHldOsjdAQN"}
{"name":"Journal Update ID With Name","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Replaces the reference id to other items/tables/journals/actors to use their name.\n * Useful for after importing journal records from a compendium that has references to actors/items/etc...\n * Author: @KrishMero#1792\n */\n \ngame.journal.forEach(entry => {\n  let content = entry.data.content;\n  let matches = content.match(/@\\w*\\[\\w*\\]/g);\n  // now we have an array of things such as @Actor[5c8HWfrpvRV4XtZ1]\n  let uniqueMatches = matches\n    .filter((value, index, self) => self.indexOf(value) === index) //unique matches\n    .forEach(str => {\n      let arrayData = str.slice(1, -1).split('['); // cut off the @ and ] then make [0] the type and [1] the id.\n      // since the reference may not match directly with the game entity type, lets look that up.\n      let entityType = getEntityType(arrayData[0]);\n      let id = arrayData[1];\n      // with the id and our entity type, look up the name of the entry.\n      let name = game[entityType].get(id)?.name;\n      if (!name) {\n        return ui.notifications.error(`Could not find any record for the entity type ${entityType} with the id of ${id}`);\n      }\n\n      // replace the ID with the name.\n      console.log(`updating ${id} with ${name}`);\n\n      let regEx = new RegExp(id, 'g');\n      content.replace(regEx, name);\n    }); \n  entry.update({ content });\n});\n\nfunction getEntityType(entity) {\n  switch (entity) {\n    case 'JournalEntry': return 'journal';\n    case 'RollTable': return 'tables';\n    default: return entity.toLowerCase() + 's';\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"tGXa6Bd79cHibPtM"}
{"name":"Show Modules","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Show Modules - Shows currently installed modules in foundry. Added on behalf of @vance\n */\nlet mods = '';\ngame.modules.forEach(m => {\n  let a = m.active ? 'Enabled' : 'Disabled';\n  mods = mods.concat(`${m.id}: ${a}\\n`);\n});\n\nlet d = new Dialog({\n  title: `Enabled Mods`,\n  content: `<textarea style=\"height: 500px;\" type=\"text\" id=\"modslist\" name=\"modslist\">${mods}</textarea>`,\n  buttons: {\n    copy: {\n      label: `Copy to clipboard`,\n      callback: () => {\n        $(\"#modslist\").select();\n        document.execCommand('copy');\n      }\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {}\n});\n\nd.render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"u71xIHwO8uVaLS8o"}
{"_id":"wosXzUFEMQLD84so","name":"Ambient Light Quick Edit","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let macroName = \"AmbientLight QuickEditor\"\nlet macroEndLog = \"---------------------------------------------\"\n\nlet i=0;\nlet lights = canvas.lighting.objects.children;\nlet lightSelected = lights[0];\nlet selectOptions = \"\";\nlet lightSelectedAngle = 0;\nlet lightSelectedBright = 0;\nlet lightSelectedDim = 0;\nlet lightSelectedRotation = 0;\nlet lightSelectedTintAlpha = 1;\nlet lightSelectedTintColor = \"\";\n\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} by PaperPunk`);\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} | Start`);\n\nconst drawingDetails = {\n      author: game.user._id,\n      fillAlpha: 0,\n      fillColor: \"#808080\",\n      fillType: 1,\n      fontFamily: \"FontAwesome\",\n      fontSize: 24,\n      height: 48,\n      hidden: false,\n      locked: false,\n      rotation: 0,\n      strokeAlpha: 1,\n      strokeColor: \"#000000\",\n      strokeWidth: 2,\n      text: i,\n      textAlpha: 1,\n      textColor: \"#ffffff\",\n      type: \"r\",\n      width: 48,\n      //x: 250,\n      x: lightSelected.x-24,\n      //y: 250\n      y: lightSelected.y+25\n};\n\n//let d = Drawing.create(drawingDetails);\n//d.update({\"x\": lights[i].x-24, \"y\": lights[i].y+25, \"text\": i});\n\nfor (i= 0; i< lights.length; i++) {\n selectOptions += `<option value=\"${i}\">AmbientLight ${i}</option>`;\n}\n\nconst htmlLightSelection = `\n    <form>\n      <h2>Select your light.</h2>\n      <div class=\"form-group\">\n        <label>Light:</label>\n        <select id=\"light-selector\" name=\"light-selector\">\n          ${selectOptions}\n        </select>\n      </div>\n    </form>\n    `;\n\nlet dialogSelector = new Dialog({\n  title: `${macroName}`,\n  content: htmlLightSelection,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Confirm`,\n      callback: htmlLightSelection => { \n        lightSelected = (htmlLightSelection.find('[name=\"light-selector\"]')[0].value)\n        lightSelectedAngle = lights[lightSelected].data.angle;\n        lightSelectedBright = lights[lightSelected].data.bright;\n        lightSelectedDim = lights[lightSelected].data.dim;\n        lightSelectedRotation = lights[lightSelected].data.rotation;\n        lightSelectedTintAlpha = lights[lightSelected].data.tintAlpha;\n        lightSelectedTintColor = lights[lightSelected].data.tintColor;\n        //console.log(`${macroName} | lightSelected = ${lightSelected}`);\n        //console.log(`${macroName} | lightSelectedBright = ${lightSelectedBright}`);\n        dialogEditor.render(true);\n      }\n    },\n    cancel: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`,\n      callback: () => {\n        console.log(`${macroName} | Goodbye`);\n        console.log(macroEndLog);\n      }\n    },\n  },\n  default: \"cancel\",\n  //close: () => console.log(\"AmbientLight QuickEditor | Dialog Window Closed\")\n});\n\nlet dialogEditor = new Dialog({\n  title: `${macroName}`,\n  content: `<h2>Edit your light.</h2>\n      <p>Emission Angle: ${lightSelectedAngle}</p>\n      <p>Bright light distance: ${lightSelectedBright}</p>\n      <p>Dim light distance: ${lightSelectedDim}</p>\n      <p>Rotation CW from down: ${lightSelectedRotation}</p>\n      <p>Tint Alpha: ${lightSelectedAngle}</p>\n      <p>Tint Color HexCode: ${lightSelectedAngle}</p>`,\n  buttons: {\n    rot5cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 5* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 15* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 45* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+45});\n        dialogEditor.render(true);\n      }\n    },\n    rot5ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 5* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 15* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 45* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-45});\n        dialogEditor.render(true);\n      }\n    },\n    brightup: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Increase Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright+5});\n        dialogEditor.render(true);\n      }\n    },\n    brightdown: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Decrease Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright-5});\n        dialogEditor.render(true);\n      }\n    },\n    brightoff: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Remove Bright Light`,\n      callback: () => { \n        lights[lightSelected].update({\"bright\":0});\n        dialogEditor.render(true);\n      }\n    },\n    dimup: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Increase Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim+5});\n        dialogEditor.render(true);\n      }\n    },\n    dimdown: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Decrease Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim-5});\n        dialogEditor.render(true);\n      }\n    },\n    dimoff: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Remove Dim Light`,\n      callback: () => { \n        lights[lightSelected].update({\"dim\":0});\n        dialogEditor.render(true);\n      }\n    },\n    emit15: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 15*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":15});\n        dialogEditor.render(true);\n      }\n    },\n    emit45: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 45*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":45});\n        dialogEditor.render(true);\n      }\n    },\n    emit90: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 90*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":90});\n        dialogEditor.render(true);\n      }\n    },\n    emit180: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 180*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":180});\n        dialogEditor.render(true);\n      }\n    },\n    emit270: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 270*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":270});\n        dialogEditor.render(true);\n      }\n    },\n    emit360: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 360*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":360});\n        dialogEditor.render(true);\n      }\n    },\n    back: {\n      icon: \"<i class='fas fa-reply'></i>\",\n      label: `Back`,\n      callback: () => dialogSelector.render(true)\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {\n    console.log(`${macroName} | Goodbye`);\n    console.log(macroEndLog);\n  }\n});\n\ndialogSelector.render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Lock All Doors","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.sSGS2FhGOqiTIpRV"}},"scope":"global","command":"/**\n * Locks all closed doors on the canvas\n * Author: orcnog\n */\n \ncanvas.walls.updateMany(canvas.scene.data.walls.map(w => {\n  return {_id: w._id, ds: w.ds === 0 ? 2 : w.ds};\n}));","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"zsAzgwdGPAeArcIJ"}
